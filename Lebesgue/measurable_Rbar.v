(**
This file is part of the Elfic library

Copyright (C) Boldo, ClÃ©ment, Faissole, Martin, Mayero, Mouhcine

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
COPYING file for more details.
*)

From Coq Require Import Lia Qreals Reals Lra.
From Coquelicot Require Import Hierarchy Rbar.

From Lebesgue Require Import nat_compl countable_sets.
From Lebesgue Require Import Rbar_compl UniformSpace_compl topo_bases_R.
From Lebesgue Require Import Subset Subset_dec Subset_seq Subset_Rbar.
From Lebesgue Require Import Subset_system_def Subset_system_base Subset_system.
From Lebesgue Require Import measurable measurable_R.


Section measurable_Rbar_Borel_Def.

(**
 Borel subsets of Rbar.

 - Borel subsets of Rbar are generated by the open subsets of Rbar;

 - Borel subsets of Rbar are either:
    + Borel subsets of R,
    + the union of Borel subsets of R and -infty,
    + the union of Borel subsets of R and infty,
    + the union of Borel subsets of R, -infty, and infty.
 *)

Definition measurable_Rbar_Borel : (Rbar -> Prop) -> Prop :=
  @measurable_Borel Rbar_UniformSpace.

Definition measurable_Rbar_R : (Rbar -> Prop) -> Prop :=
  fun B => measurable_R (down B).

Inductive measurable_Rbar_R_alt : (Rbar -> Prop) -> Prop :=
  | MRRb : forall A, measurable_R A -> measurable_Rbar_R_alt (up_id A)
  | MRRb_m : forall A, measurable_R A -> measurable_Rbar_R_alt (up_m A)
  | MRRb_p : forall A, measurable_R A -> measurable_Rbar_R_alt (up_p A)
  | MRRb_mp : forall A, measurable_R A -> measurable_Rbar_R_alt (up_mp A).

End measurable_Rbar_Borel_Def.


Section measurable_Rbar_Borel_Facts.

(** Preliminary results on measurable_Rbar_Borel. *)

Lemma measurable_Rbar_Borel_singleton :
  forall a, measurable_Rbar_Borel (singleton a).
Proof.
intros; apply measurable_Borel_closed, closed_Rbar_eq.
Qed.

Lemma measurable_Rbar_Borel_up_id :
  forall A, measurable_R A -> measurable_Rbar_Borel (up_id A).
Proof.
rewrite measurable_R_eq_Borel.
intros A HA; induction HA as [A HA | | A HA1 HA2 | A HA1 HA2].
(* *)
apply measurable_gen; rewrite <- Rbar_subset_open_correct; apply RbSO_woinf; easy.
(* *)
apply measurable_ext with emptyset;
    [rewrite <- up_id_empty at 1; easy | apply measurable_empty].
(* *)
rewrite up_id_compl; apply measurable_compl.
repeat apply measurable_union; try easy; apply measurable_Rbar_Borel_singleton.
(* *)
rewrite up_id_union_seq; apply measurable_union_seq; easy.
Qed.

Lemma measurable_Rbar_Borel_up_m :
  forall A, measurable_R A -> measurable_Rbar_Borel (up_m A).
Proof.
intros; apply measurable_union.
apply measurable_Rbar_Borel_up_id; easy.
apply measurable_Rbar_Borel_singleton.
Qed.

Lemma measurable_Rbar_Borel_up_p :
  forall A, measurable_R A -> measurable_Rbar_Borel (up_p A).
Proof.
intros; apply measurable_union.
apply measurable_Rbar_Borel_up_id; easy.
apply measurable_Rbar_Borel_singleton.
Qed.

Lemma measurable_Rbar_Borel_up_mp :
  forall A, measurable_R A -> measurable_Rbar_Borel (up_mp A).
Proof.
intros; apply measurable_union.
apply measurable_Rbar_Borel_up_m; easy.
apply measurable_Rbar_Borel_singleton.
Qed.

(** Preliminary results on measurable_Rbar_R. *)

Lemma measurable_Rbar_R_open_R :
  Incl open (fun A => measurable_Rbar_R (up_id A)).
Proof.
unfold measurable_Rbar_R.
intros A; rewrite down_up_id; apply measurable_R_open; easy.
Qed.

Lemma measurable_Rbar_R_union : Union measurable_Rbar_R.
Proof.
unfold measurable_Rbar_R.
intros A B HA; rewrite down_union; apply measurable_union; easy.
Qed.

Lemma measurable_Rbar_R_gt : forall a, measurable_Rbar_R (Rbar_gt a).
Proof.
unfold measurable_Rbar_R; intros a; destruct a.
rewrite Rbar_gt_eq, down_up_m; apply measurable_R_gt.
rewrite Rbar_gt_p_eq, down_up_m; apply measurable_full.
apply measurable_ext with emptyset; [Rbar_interval_auto | apply measurable_empty].
Qed.

Lemma measurable_Rbar_R_lt : forall a, measurable_Rbar_R (Rbar_lt a).
Proof.
unfold measurable_Rbar_R; intros a; destruct a.
rewrite Rbar_lt_eq, down_up_p; apply measurable_R_lt.
apply measurable_ext with emptyset; [Rbar_interval_auto | apply measurable_empty].
rewrite Rbar_lt_m_eq, down_up_p; apply measurable_full.
Qed.

Lemma measurable_Rbar_R_open : Incl open measurable_Rbar_R.
Proof.
intros B HB; rewrite <- Rbar_subset_open_correct in HB.
induction HB as [A HA | B HB].
apply measurable_Rbar_R_open_R; easy.
induction HB as [A B HA HB | A a b HA]; [induction HB as [b Hb | a Ha] | ];
    repeat apply measurable_Rbar_R_union;
    try now apply measurable_Rbar_R_open_R.
all: try apply measurable_Rbar_R_gt; apply measurable_Rbar_R_lt.
Qed.

Lemma measurable_Rbar_R_is_sigma_algebra : is_Sigma_algebra measurable_Rbar_R.
Proof.
apply Sigma_algebra_equiv; repeat split; unfold measurable_Rbar_R, wEmpty.
rewrite down_empty; apply measurable_empty.
intros A; rewrite down_compl; apply measurable_compl; easy.
intros A HA; rewrite down_union_seq; apply measurable_union_seq; easy.
Qed.

(** Correctness results. *)

Lemma measurable_Rbar_R_eq :
  measurable_Rbar_R = measurable_Rbar_R_alt.
Proof.
apply Ext_equiv; split; intros B; unfold measurable_Rbar_R.
(* *)
generalize (Rbar_subset_correct B); intros HB; induction HB.
rewrite down_up_id; apply MRRb; easy.
rewrite down_up_m; apply MRRb_m; easy.
rewrite down_up_p; apply MRRb_p; easy.
rewrite down_up_mp; apply MRRb_mp; easy.
(* *)
intros HB; induction HB.
rewrite down_up_id; easy.
rewrite down_up_m; easy.
rewrite down_up_p; easy.
rewrite down_up_mp; easy.
Qed.

Lemma measurable_Rbar_Borel_R :
  Incl measurable_Rbar_Borel measurable_Rbar_R.
Proof.
apply measurable_gen_lub_alt.
apply measurable_Rbar_R_is_sigma_algebra.
apply measurable_Rbar_R_open.
Qed.

Lemma measurable_Rbar_R_alt_Borel :
  Incl measurable_Rbar_R_alt measurable_Rbar_Borel.
Proof.
intros B HB; induction HB as [A HA | A HA | A HA | A HA].
apply measurable_Rbar_Borel_up_id; easy.
apply measurable_Rbar_Borel_up_m; easy.
apply measurable_Rbar_Borel_up_p; easy.
apply measurable_Rbar_Borel_up_mp; easy.
Qed.

Lemma measurable_Rbar_R_correct :
  measurable_Rbar_R = measurable_Rbar_Borel.
Proof.
apply Ext_equiv; split.
rewrite measurable_Rbar_R_eq; apply measurable_Rbar_R_alt_Borel.
apply measurable_Rbar_Borel_R.
Qed.

Lemma measurable_Rbar_R_alt_correct :
  measurable_Rbar_R_alt = measurable_Rbar_Borel.
Proof.
rewrite <- measurable_Rbar_R_eq; apply measurable_Rbar_R_correct.
Qed.

End measurable_Rbar_Borel_Facts.


Section gen_Rbar_Def.

Inductive gen_Rbar_ge : (Rbar -> Prop) -> Prop :=
  GRb_ge : forall (b : R), gen_Rbar_ge (Rbar_ge b).
Inductive gen_Rbar_gt : (Rbar -> Prop) -> Prop :=
  GRb_gt : forall (b : R), gen_Rbar_gt (Rbar_gt b).
Inductive gen_Rbar_le : (Rbar -> Prop) -> Prop :=
  GRb_le : forall (a : R), gen_Rbar_le (Rbar_le a).
Inductive gen_Rbar_lt : (Rbar -> Prop) -> Prop :=
  GRb_lt : forall (a : R), gen_Rbar_lt (Rbar_lt a).

Inductive gen_Rbar_topo_basis : (Rbar -> Prop) -> Prop :=
  GRb_tb : forall n, gen_Rbar_topo_basis (topo_basis_Rbar n).

End gen_Rbar_Def.


Section measurable_Rbar_Borel_eq.

(* WIP: alternate path...
Lemma measurable_Rbar_R_alt_incl_lt :
  Incl measurable_Rbar_R_alt (measurable gen_Rbar_lt).
Proof.
intros B HB; induction HB as [A HA | A HA | A HA | A HA];
    rewrite measurable_R_eq_lt in HA.
Admitted.

Lemma measurable_Rbar_R_eq_lt :
  measurable_Rbar_R = measurable gen_Rbar_lt.
Proof.
apply Ext_equiv; split.
(* *)
unfold measurable_Rbar_R; rewrite measurable_R_eq_lt; intros B HB.
admit.
(* *)
apply measurable_gen_lub_alt.
apply measurable_Rbar_R_is_sigma_algebra.
intros B HB; induction HB as [a].
apply measurable_ext with (Rlt a); try easy.
apply measurable_R_lt.
Admitted.

Lemma measurable_Rbar_Borel_eq_lt :
  measurable_Rbar_Borel = measurable gen_Rbar_lt.
Proof.
rewrite <- measurable_Rbar_R_correct.
apply measurable_Rbar_R_eq_lt.
Qed.
*)

Lemma gen_Rbar_topo_basis_empty : exists n, empty (topo_basis_Rbar n).
Proof.
pose (n := bij_Q2N (0, 0)%Q).
exists (2 * n + 1)%nat.
unfold topo_basis_Rbar.
destruct (Even_Odd_dec (2 * n + 1)%nat) as [Hn | Hn].
destruct (Nat.Even_Odd_False _ Hn); exists n; easy.
rewrite Rbar_oo_diag_is_empty; easy.
Qed.

Lemma measurable_Rbar_Borel_eq_topo_basis :
  measurable_Rbar_Borel = measurable gen_Rbar_topo_basis.
Proof.
unfold measurable_Rbar_Borel.
rewrite (measurable_Borel_eq_topo_basis topo_basis_Rbar).
f_equal; apply subset_ext_equiv; split; intros x Hx; induction Hx; easy.
apply Rbar_second_countable.
apply gen_Rbar_topo_basis_empty.
Qed.

Lemma measurable_Rbar_gt_le :
  forall (a : R), measurable gen_Rbar_gt (Rbar_le a).
Proof.
intros; apply measurable_ext with (compl (Rbar_gt a)).
split; [apply Rbar_not_lt_le | apply Rbar_le_not_lt].
apply measurable_compl, measurable_gen; easy.
Qed.

Lemma measurable_Rbar_gt_lt :
  forall (a : R), measurable gen_Rbar_gt (Rbar_lt a).
Proof.
intros a; apply measurable_ext with (union_seq (Rbar_le_eps a)).
rewrite Rbar_lt_is_Rbar_le_union_seq; easy.
apply measurable_union_seq; intro; apply measurable_Rbar_gt_le.
Qed.

Lemma measurable_Rbar_topo_basis_gt :
  forall (b : R), measurable gen_Rbar_topo_basis (Rbar_gt b).
Proof.
intros b; apply measurable_ext with
    (union_seq (fun n => let qn := Q2R (bij_NQ n) in
       inter (Prop_cst (Rbar_gt b qn)) (Rbar_gt qn))).
(* *)
intros y; split.
intros [n [Hn1 Hn2]]; apply Rbar_lt_trans with (Q2R (bij_NQ n)); easy.
intros Hb; destruct y as [x | | ]; simpl; try easy.
destruct (Q_dense _ _ Hb) as [q Hq].
exists (bij_QN q); rewrite bij_NQN; split; easy.
destruct (Q_dense (b - 1) b) as [q [_ Hq]]; try lra.
exists (bij_QN q); rewrite bij_NQN; split; easy.
(* *)
apply measurable_union_seq; intros k;
    apply measurable_inter; [apply measurable_Prop | apply measurable_gen].
pose (m := (2 * k + 1)%nat). pose (n := (2 * m)%nat).
rewrite subset_ext with (B := topo_basis_Rbar n); try easy.
unfold topo_basis_Rbar; destruct (Even_Odd_dec n) as [Hk1 | Hk1].
destruct (Even_Odd_dec (Nat.div2 n)) as [Hk2 | Hk2];
    unfold n, m in *; rewrite Nat.div2_double in *.
destruct (Nat.Even_Odd_False _ Hk2); exists k; easy.
replace (2 * k + 1 - 1)%nat with (2 * k)%nat; try lia.
rewrite Nat.div2_double; easy.
destruct (Nat.Even_Odd_False n); try easy; exists m; easy.
Qed.

Lemma measurable_Rbar_Borel_eq_gt :
  measurable_Rbar_Borel = measurable gen_Rbar_gt.
Proof.
rewrite measurable_Rbar_Borel_eq_topo_basis.
apply measurable_gen_ext; intros B HB.
(* *)
induction HB as [n]; unfold topo_basis_Rbar.
destruct (Even_Odd_dec n) as [Hn1 | Hn1]; try apply measurable_inter.
destruct (Even_Odd_dec (Nat.div2 n)) as [Hn2 | Hn2].
2,4: apply measurable_gen; easy.
1,2: apply measurable_Rbar_gt_lt; easy.
(* *)
induction HB as [a].
apply measurable_Rbar_topo_basis_gt.
Qed.

Lemma measurable_Rbar_Borel_eq_le :
  measurable_Rbar_Borel = measurable gen_Rbar_le.
Proof.
rewrite measurable_Rbar_Borel_eq_gt.
apply measurable_gen_ext; intros B HB.
(* *)
induction HB as [b].
apply measurable_ext with (compl (Rbar_le b)).
split; [apply Rbar_not_le_lt | apply Rbar_lt_not_le].
apply measurable_compl, measurable_gen; easy.
(* *)
induction HB as [a].
apply measurable_ext with (compl (Rbar_gt a)).
split; [apply Rbar_not_lt_le | apply Rbar_le_not_lt].
apply measurable_compl, measurable_gen; easy.
Qed.

Lemma measurable_Rbar_lt_ge :
  forall (b : R), measurable gen_Rbar_lt (Rbar_ge b).
Proof.
intros; apply measurable_ext with (compl (Rbar_lt b)).
split; [apply Rbar_not_lt_le | apply Rbar_le_not_lt].
apply measurable_compl, measurable_gen; easy.
Qed.

Lemma measurable_Rbar_lt_gt :
  forall (b : R), measurable gen_Rbar_lt (Rbar_gt b).
Proof.
intros b; apply measurable_ext with (union_seq (Rbar_ge_eps b)).
rewrite Rbar_gt_is_Rbar_ge_union_seq; easy.
apply measurable_union_seq; intro; apply measurable_Rbar_lt_ge.
Qed.

Lemma measurable_Rbar_topo_basis_lt :
  forall (a : R), measurable gen_Rbar_topo_basis (Rbar_lt a).
Proof.
intros a; apply measurable_ext with
    (union_seq (fun n => let qn := Q2R (bij_NQ n) in
       inter (Prop_cst (Rbar_lt a qn)) (Rbar_lt qn))).
(* *)
intros y; split.
intros [n [Hn1 Hn2]]; apply Rbar_lt_trans with (Q2R (bij_NQ n)); easy.
intros Ha; destruct y as [x | | ]; simpl; try easy.
destruct (Q_dense _ _ Ha) as [q Hq].
exists (bij_QN q); rewrite bij_NQN; split; easy.
destruct (Q_dense a (a + 1)) as [q [Hq _]]; try lra.
exists (bij_QN q); rewrite bij_NQN; split; try easy.
(* *)
apply measurable_union_seq; intros k;
    apply measurable_inter; [apply measurable_Prop | apply measurable_gen].
pose (m := (2 * k)%nat). pose (n := (2 * m)%nat).
rewrite subset_ext with (B := topo_basis_Rbar n); try easy.
unfold topo_basis_Rbar; destruct (Even_Odd_dec n) as [Hk1 | Hk1].
destruct (Even_Odd_dec (Nat.div2 n)) as [Hk2 | Hk2];
    unfold n, m in *; rewrite Nat.div2_double in *.
rewrite Nat.div2_double; easy.
destruct (Nat.Even_Odd_False m); try easy; exists k; easy.
destruct (Nat.Even_Odd_False n); try easy; exists m; easy.
Qed.

Lemma measurable_Rbar_Borel_eq_lt :
  measurable_Rbar_Borel = measurable gen_Rbar_lt.
Proof.
rewrite measurable_Rbar_Borel_eq_topo_basis.
apply measurable_gen_ext; intros B HB.
(* *)
induction HB as [n]; unfold topo_basis_Rbar.
destruct (Even_Odd_dec n) as [Hn1 | Hn1]; try apply measurable_inter.
destruct (Even_Odd_dec (Nat.div2 n)) as [Hn2 | Hn2].
1,3: apply measurable_gen; easy.
1,2: apply measurable_Rbar_lt_gt; easy.
(* *)
induction HB as [a].
apply measurable_Rbar_topo_basis_lt.
Qed.

Lemma measurable_Rbar_Borel_eq_ge :
  measurable_Rbar_Borel = measurable gen_Rbar_ge.
Proof.
rewrite measurable_Rbar_Borel_eq_lt.
apply measurable_gen_ext; intros B HB.
(* *)
induction HB as [a].
apply measurable_ext with (compl (Rbar_ge a)).
split; [apply Rbar_not_le_lt | apply Rbar_lt_not_le].
apply measurable_compl, measurable_gen; easy.
(* *)
induction HB as [b].
apply measurable_ext with (compl (Rbar_lt b)).
split; [apply Rbar_not_lt_le | apply Rbar_le_not_lt].
apply measurable_compl, measurable_gen; easy.
Qed.

End measurable_Rbar_Borel_eq.


Section measurable_Rbar.

Definition gen_Rbar := gen_Rbar_lt.
Definition measurable_Rbar := measurable gen_Rbar.

Lemma measurable_Rbar_eq_Borel : measurable_Rbar = measurable_Borel.
Proof.
unfold measurable_Rbar, gen_Rbar; rewrite <- measurable_Rbar_Borel_eq_lt; easy.
Qed.

Lemma measurable_Rbar_open : Incl open measurable_Rbar.
Proof.
rewrite measurable_Rbar_eq_Borel; apply measurable_Borel_open.
Qed.

Lemma measurable_Rbar_closed : Incl closed measurable_Rbar.
Proof.
rewrite measurable_Rbar_eq_Borel; apply measurable_Borel_closed.
Qed.

Lemma measurable_Rbar_singleton : forall a, measurable_Rbar (singleton a).
Proof.
rewrite measurable_Rbar_eq_Borel; apply measurable_Rbar_Borel_singleton.
Qed.

Lemma measurable_Rbar_eq_ge : measurable_Rbar = measurable gen_Rbar_ge.
Proof.
rewrite <- measurable_Rbar_Borel_eq_ge, measurable_Rbar_Borel_eq_lt; easy.
Qed.

Lemma measurable_Rbar_eq_gt : measurable_Rbar = measurable gen_Rbar_gt.
Proof.
rewrite <- measurable_Rbar_Borel_eq_gt, measurable_Rbar_Borel_eq_lt; easy.
Qed.

Lemma measurable_Rbar_eq_le : measurable_Rbar = measurable gen_Rbar_le.
Proof.
rewrite <- measurable_Rbar_Borel_eq_le, measurable_Rbar_Borel_eq_lt; easy.
Qed.

Lemma measurable_Rbar_ge : forall b, measurable_Rbar (Rbar_ge b).
Proof.
intros; apply measurable_Rbar_closed, closed_Rbar_ge.
Qed.

Lemma measurable_Rbar_gt : forall b, measurable_Rbar (Rbar_gt b).
Proof.
intros; apply measurable_Rbar_open, open_Rbar_gt.
Qed.

Lemma measurable_Rbar_le : forall a, measurable_Rbar (Rbar_le a).
Proof.
intros; apply measurable_Rbar_closed, closed_Rbar_le.
Qed.

Lemma measurable_Rbar_lt : forall a, measurable_Rbar (Rbar_lt a).
Proof.
intros; apply measurable_Rbar_open, open_Rbar_lt.
Qed.

Lemma measurable_Rbar_cc : forall a b, measurable_Rbar (Rbar_cc a b).
Proof.
intros; apply measurable_Rbar_closed, closed_Rbar_intcc.
Qed.

Lemma measurable_Rbar_co : forall a b, measurable_Rbar (Rbar_co a b).
Proof.
intros; apply measurable_inter;
    [apply measurable_Rbar_le | apply measurable_Rbar_gt].
Qed.

Lemma measurable_Rbar_oc : forall a b, measurable_Rbar (Rbar_oc a b).
Proof.
intros; apply measurable_inter;
    [apply measurable_Rbar_lt | apply measurable_Rbar_ge].
Qed.

Lemma measurable_Rbar_oo : forall a b, measurable_Rbar (Rbar_oo a b).
Proof.
intros; apply measurable_Rbar_open, open_Rbar_intoo.
Qed.

Lemma measurable_Rbar_is_finite : measurable_Rbar is_finite.
Proof.
apply measurable_Rbar_open, open_Rbar_is_finite.
Qed.

Lemma measurable_Rbar_eq_R : measurable_Rbar = measurable_Rbar_R.
Proof.
rewrite measurable_Rbar_eq_Borel, measurable_Rbar_R_correct; easy.
Qed.

Lemma measurable_Rbar_eq_R_alt : measurable_Rbar = measurable_Rbar_R_alt.
Proof.
rewrite measurable_Rbar_eq_Borel, measurable_Rbar_R_alt_correct; easy.
Qed.

(* WIP [lazy]: wait for actually needing it...
Lemma measurable_Rbar_abs :
  forall B, measurable_Rbar B -> measurable_Rbar (fun y => B (Rbar_abs y)).
Proof.
Admitted.
*)

(* WIP [lazy]: wait for actually needin it...
Lemma measurable_Rbar_scal :
  forall B l,
    measurable_Rbar B -> measurable_Rbar (fun y => B (Rbar_mult l y)).
Proof.
Admitted.
*)

End measurable_Rbar.
