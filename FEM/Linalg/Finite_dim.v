From Coq Require Import ClassicalEpsilon.
From Coq Require Import ssreflect ssrfun ssrbool.

Set Warnings "-notation-overridden".
From mathcomp Require Import ssrnat fintype.

From LM Require Import linear_map.
Set Warnings "notation-overridden".

From Lebesgue Require Import Subset Function.

From FEM Require Import Compl nat_compl ord_compl Finite_family Finite_table.
From FEM Require Import Monoid_compl Group_compl Ring_compl ModuleSpace_compl.
From FEM Require Import Sub_struct AffineSpace.


(** Results needing a commutative Ring are only stated for
 the ring of real numbers R_Ring. *)


Local Open Scope Monoid_scope.
Local Open Scope Group_scope.
Local Open Scope Ring_scope.


Section FD_Def.

(** Definitions.

  Let E be a real vector space.
  Let PE be a subset of E.
  Let B be an n-family of vectors in E.
  Let x, y, z be vectors in E.

  "span B" is the subset of the linear combinations of vectors of B.
  Lemma span_EX provides a strong existential for spans.
  Lemma span_ex provides some smoothness to build the linear combination.

  "in_line x" is the subset of E generated by x.
  It is a vector line iff x <> 0.

  "in_plane x y" is the subset of E generated by x and y.
  It is a vector plane iff x <> 0 /\ y <> scal lx x.

  "in_3d_space x y z" is the subset of E generated by x, y and z.
  It is a vector 3d-space iff x <> 0 /\ y <> scal lx x /\ z <> scal lx x + scal ly y .

  "comb_lin_surjL PE B" means that each element of PE is a linear combination of B.
  "comb_lin_injL B" means that linear combinations of B are unique.
  "comb_lin_bijL PE B" means that each element of PE is a unique linear combination of B.

  "is_generator PE B" means that the vectors of B span PE (i.e. PE = span B).

  "is_free B" means that the trivial linear combination of B is the only decomposition of 0,
    i.e. that the vectors of B are linearly independent.

  "is_basis PE B" means that B is both generator of PE and free, a.k.a. a basis of PE.

  "has_dim PE n" means that PE admits a basis of length n.

  "dim PE" returns n when PE admits a basis of length n, and 0 otherwise.
*)

Context {K : Ring}.
Context {E : ModuleSpace K}.

(* TODO FC (07/06/2023): try to use new span_struct. *)

Inductive span {n} (B : 'E^n) : E -> Prop :=
  Span : forall L, span B (comb_lin L B).

Lemma span_EX :
  forall {n} (B : 'E^n) x, span B x -> { L | x = comb_lin L B }.
Proof.
move=>> Hx; apply constructive_indefinite_description.
induction Hx as [L]; exists L; easy.
Qed.

Lemma span_ex :
  forall {n} (B : 'E^n) x, (exists L, x = comb_lin L B) -> span B x.
Proof. move=>> [L HL]; rewrite HL; easy. Qed.

Lemma span_ext : forall {n} (B1 B2 : 'E^n), B1 = B2 -> span B1 = span B2.
Proof. intro; apply f_equal. Qed.

Definition in_line (x0 : E) := span (singleF x0).
Definition in_plane (x0 x1 : E) := span (coupleF x0 x1).
Definition in_3d_space (x0 x1 x2 : E) := span (tripleF x0 x1 x2).

Definition comb_lin_surjL (PE : E -> Prop) {n} (B : 'E^n) :=
  forall x, PE x -> exists L, x = comb_lin L B.
Definition comb_lin_injL {n} (B : 'E^n) := injective (comb_lin^~ B).
(*  forall L L', comb_lin L B = comb_lin L' B -> L = L'.*)
Definition comb_lin_bijL (PE : E -> Prop) {n} (B : 'E^n) :=
  forall x, PE x -> exists! L, x = comb_lin L B.

Definition is_generator (PE : E -> Prop) {n} (B : 'E^n) := PE = span B.

Lemma is_generator_ext :
  forall (PE : E -> Prop) {n} (B1 B2 : 'E^n),
    B1 = B2 -> is_generator PE B1 -> is_generator PE B2.
Proof. intros; subst; easy. Qed.

Definition is_free {n} (B : 'E^n) :=
  forall (L : 'K^n), comb_lin L B = 0 -> L = 0.

Lemma is_free_ext :
  forall {n} (B1 B2 : 'E^n), B1 = B2 -> is_free B1 -> is_free B2.
Proof. intros; subst; easy. Qed.

(* FC: this could be a notation... *)
Definition is_lin_dep {n} (B : 'E^n) := ~ is_free B.

Lemma is_lin_dep_ext :
  forall {n} (B1 B2 : 'E^n), B1 = B2 -> is_lin_dep B1 -> is_lin_dep B2.
Proof. intros; subst; easy. Qed.

Definition is_basis (PE : E -> Prop) {n} (B : 'E^n) :=
  is_generator PE B /\ is_free B.

Lemma is_basis_ext :
  forall (PE : E -> Prop) {n} (B1 B2 : 'E^n),
    B1 = B2 -> is_basis PE B1 -> is_basis PE B2.
Proof. intros; subst; easy. Qed.

Inductive has_dim (PE : E -> Prop) n : Prop :=
  Dim : forall (B : 'E^n), is_basis PE B -> has_dim PE n.

Lemma has_dim_EX :
  forall (PE : E -> Prop) n, has_dim PE n -> { B : 'E^n | is_basis PE B }.
Proof.
move=>> H; apply constructive_indefinite_description.
induction H as [B]; exists B; easy.
Qed.

Lemma has_dim_ex:
  forall (PE : E -> Prop) n,
    (exists B : 'E^n, is_basis PE B) -> has_dim PE n.
Proof. move=>> [B HB]. apply (Dim _ _ B HB). Qed.

Lemma has_dim_ext :
  forall (PE1 PE2 : E -> Prop) n1 n2,
    PE1 = PE2 -> n1 = n2 -> has_dim PE1 n1 -> has_dim PE2 n2.
Proof. intros; subst; easy. Qed.

Definition dim (PE : E -> Prop) :=
  match (LPO (has_dim PE) (fun=> classic _)) with
  | inleft H => proj1_sig H
  | inright _ => O
  end.

Lemma dim_ext : forall (PE1 PE2 : E -> Prop), PE1 = PE2 -> dim PE1 = dim PE2.
Proof. apply f_equal. Qed.

End FD_Def.


Section Span_Subset_Facts.

(** Subset properties of span. *)

Context {K : Ring}.
Context {E : ModuleSpace K}.

Lemma span_inclF_diag : forall {n} (B : 'E^n), inclF B (span B).
Proof. intros n B i; rewrite -comb_lin_kron_in_r; easy. Qed.

Lemma span_ub : forall {n} (B : 'E^n) A i, A = B i -> span B A.
Proof. intros; subst; apply span_inclF_diag. Qed.

Lemma span_nil : forall (B : 'E^0), span B = zero_sub_struct.
Proof.
intros B; apply subset_ext_equiv; split.
intros _ [L]; apply comb_lin_nil.
intros x Hx; rewrite Hx -(comb_lin_zero_compat_l 0 B); easy.
Qed.

Lemma span_zero : forall {n}, span (0 : 'E^n) = zero_sub_struct.
Proof.
intros; apply subset_ext_equiv; split.
intros _ [L]; apply comb_lin_zero_r.
intros x Hx; rewrite Hx -(comb_lin_zero_compat_r (0 : 'K^n) 0); easy.
Qed.

Lemma span_singleF : forall (B : 'E^1), span B = in_line (B ord0).
Proof. intros B; rewrite -> (singleF_correct B) at 1; easy. Qed.

Lemma span_coupleF :
  forall (B : 'E^2), span B = in_plane (B ord0) (B ord_max).
Proof. intros B; rewrite -> (coupleF_correct B) at 1; easy. Qed.

Lemma span_tripleF :
  forall (B : 'E^3), span B = in_3d_space (B ord0) (B ord_1) (B ord_max).
Proof. intros B; rewrite -> (tripleF_correct B) at 1; easy. Qed.

Lemma span_inclF :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2), invalF B1 B2 -> inclF B1 (span B2).
Proof.
move=>> HB i; destruct (HB i) as [i2 Hi2]; rewrite Hi2; apply span_inclF_diag.
Qed.

Lemma spanF_ex :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B1 (span B2) <-> exists M12, forall i1, B1 i1 = comb_lin (M12 i1) B2.
Proof.
intros n1 n2 B1 B2; split; intros HB.
(* *)
assert (HB' : forall i1, exists L2, B1 i1 = comb_lin L2 B2).
  intros i1; destruct (HB i1) as [L2]; exists L2; easy.
apply (choice _ HB').
(* *)
destruct HB as [H HM]; intros i1; rewrite HM; easy.
Qed.

Lemma spanF_ex_flipT :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B1 (span B2) <-> exists M12, forall i1, B1 i1 = comb_lin (M12^~ i1) B2.
Proof.
intros; rewrite spanF_ex; split; intros [L HL];
    exists (flipT L); intros j; rewrite HL; easy.
Qed.

Lemma span_incl :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B1 (span B2) -> incl (span B1) (span B2).
Proof.
move=>> HB1 _ [L1]; apply spanF_ex in HB1; destruct HB1 as [M12 HM12].
apply span_ex; eexists; apply comb_lin2_alt; easy.
Qed.

Lemma span_monot :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    invalF B1 B2 -> incl (span B1) (span B2).
Proof. intros; apply span_incl, span_inclF; easy. Qed.

Lemma span_concatF_sym_inclF :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    inclF (concatF B1 B2) (span (concatF B2 B1)).
Proof.
intros n1 n2 B1 B2 i; apply span_ex.
destruct (lt_dec i n1) as [Hi | Hi]; eexists.
(* *)
rewrite concatF_correct_l -comb_lin_kron_in_r.
rewrite -(comb_lin_concatF_zero_lr _ _ B2) comb_lin_concatF.
rewrite plus_comm; symmetry; apply comb_lin_concatF.
(* *)
rewrite concatF_correct_r -comb_lin_kron_in_l.
rewrite -(comb_lin_concatF_zero_ll _ B1) comb_lin_concatF.
rewrite plus_comm; symmetry; apply comb_lin_concatF.
Qed.

Lemma span_eq :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B1 (span B2) -> inclF B2 (span B1) -> span B1 = span B2.
Proof. intros; apply subset_ext_equiv; split; apply span_incl; easy. Qed.

Lemma span_coupleF_sym_inclF :
  forall (x0 x1 : E), inclF  (coupleF x1 x0) (in_plane x0 x1).
Proof. intros; apply span_inclF, invalF_coupleF_sym. Qed.

Lemma span_coupleF_sym : forall (x0 x1 : E), in_plane x0 x1 = in_plane x1 x0.
Proof. intros; apply span_eq; apply span_coupleF_sym_inclF. Qed.

Lemma span_castF_compat :
  forall {n1 n2} (H : n1 = n2) (B1 : 'E^n1), span (castF H B1) = span B1.
Proof.
intros n1 n2 Hn B1; apply subset_ext_equiv; split; intros _ [L]; apply span_ex.
subst n1; exists L; apply comb_lin_eq_r, castF_refl.
subst n2; exists L; apply comb_lin_eq_r, sym_eq, castF_refl.
Qed.

Lemma span_concatF_sym :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    span (concatF B1 B2) = span (concatF B2 B1).
Proof. intros; apply span_eq; apply span_concatF_sym_inclF. Qed.

Lemma span_concatF_compat_l :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B1 (span B2) -> span B2 = span (concatF B1 B2).
Proof.
intros; apply span_eq.
(* *)
eapply (inclF_monot_r (span _)).
apply span_monot, concatF_ub_r.
apply span_inclF_diag.
(* *)
apply concatF_lub_inclF; try apply span_inclF_diag; easy.
Qed.

Lemma span_concatF_compat_r :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B2 (span B1) -> span B1 = span (concatF B1 B2).
Proof.
intros n1 n2 B1 B2 HB; apply span_eq.
(* *)
eapply (inclF_monot_r (span _)).
apply span_monot, concatF_ub_l.
apply span_inclF_diag.
(* *)
apply concatF_lub_inclF; try apply span_inclF_diag; easy.
Qed.

End Span_Subset_Facts.


Section Span_Linear_Facts.

(** Linear properties of span. *)

Context {K : Ring}.
Context {E : ModuleSpace K}.
Context {n : nat}.

Lemma span_zero_closed : forall (B : 'E^n), span B 0.
Proof. intros B; rewrite <- (comb_lin_zero_compat_l 0 B); easy. Qed.

Lemma span_scal_closed : forall (B : 'E^n), scal_closed (span B).
Proof. intros B l x [Lx]; rewrite -comb_lin_scal_l; easy. Qed.

Lemma span_opp_closed : forall (B : 'E^n), opp_closed (span B).
Proof. intros; apply scal_opp_closed, span_scal_closed. Qed.

Lemma span_plus_closed : forall (B : 'E^n), plus_closed (span B).
Proof. intros B x y [Lx] [Ly]; rewrite -comb_lin_plus_l; easy. Qed.

Lemma span_minus_closed : forall (B : 'E^n), minus_closed (span B).
Proof.
intros; apply plus_opp_minus_closed.
apply span_plus_closed.
apply span_opp_closed.
Qed.

(* span B is a vector subspace. *)
Lemma span_compatible_ms : forall (B : 'E^n), compatible_ms (span B).
Proof.
intros; apply plus_scal_closed_compatible_ms.
exists 0; apply span_zero_closed.
apply span_plus_closed.
apply span_scal_closed.
Qed.

Lemma span_comb_lin_closed : forall (B : 'E^n), comb_lin_closed (span B).
Proof. intros B m; apply compatible_ms_comb_lin, span_compatible_ms. Qed.

(* Gostiaux T1, Th 6.19 pp. 168-169. *)
Lemma span_equiv : forall (B : 'E^n), span B = span_ms (inF^~ B).
Proof.
intros; apply subset_ext_equiv; split.
(* *)
intros x Hx; induction Hx as [L]; apply span_ms_comb_lin.
intros i; apply span_ms_incl; exists i; easy.
(* *)
apply span_ms_lub.
apply span_compatible_ms.
intros x [i Hi]; rewrite Hi; apply span_inclF_diag.
Qed.

Lemma span_ex_decomp : forall (B : 'E^n), comb_lin_surjL (span B) B.
Proof. intros B _ [L]; exists L; easy. Qed.

Lemma span_lb :
  forall PE (B : 'E^n), compatible_ms PE -> inclF B PE -> incl (span B) PE.
Proof. intros PE B HPE HB x [L]; apply compatible_ms_comb_lin; easy. Qed.

Lemma span_glb :
  forall (B : 'E^n),
    span B = (fun x => forall PE, compatible_ms PE -> inclF B PE -> PE x).
  (* this could use new interp_any from Subset branch. *)
Proof.
intros B; apply subset_ext_equiv; split.
intros _ [L] PE HPE1 HPE2; apply compatible_ms_comb_lin; easy.
(* could use span_lb with properties of interp_any on compatible_ms and inclF. *)
intros x Hx; apply Hx. apply span_compatible_ms. apply span_inclF_diag.
Qed.

End Span_Linear_Facts.


Section Comb_lin_L_Facts.

(** Properties of comb_lin_surjL, comb_lin_injL and comb_lin_bijL. *)

Context {K : Ring}.
Context {E : ModuleSpace K}.
Context {n : nat}.

Variable PE : E -> Prop.
Variable B : 'E^n.

Lemma comb_lin_surjL_injL_bijL :
  comb_lin_surjL PE B -> comb_lin_injL B -> comb_lin_bijL PE B.
Proof.
intros HB1 HB2 x Hx; destruct (HB1 _ Hx) as [L HL].
exists L; split; try easy.
intros L' HL'; apply HB2; rewrite <- HL; easy.
Qed.

Lemma comb_lin_bijL_surjL : comb_lin_bijL PE B -> comb_lin_surjL PE B.
Proof. intros HB x Hx; destruct (HB _ Hx) as [L [HL _]]; exists L; easy. Qed.

Lemma comb_lin_bijL_injL :
  compatible_ms PE -> inclF B PE -> comb_lin_bijL PE B -> comb_lin_injL B.
Proof.
intros HPE HB1 HB2 L L' HL.
destruct (HB2 (comb_lin L B)) as [Lx [_ HLx]];
    try now apply compatible_ms_comb_lin.
apply trans_eq with Lx; [symmetry |]; apply HLx; easy.
Qed.

End Comb_lin_L_Facts.


Section Generator_Facts.

(** Properties of is_generator (from those of span). *)

Context {K : Ring}.
Context {E : ModuleSpace K}.
Context {n n1 n2 : nat}.

Variable PE : E -> Prop.

(* FC: Useless? *)
Lemma is_generator_span : forall (B : 'E^n), is_generator (span B) B.
Proof. easy. Qed.

Lemma is_generator_inclF : forall (B : 'E^n), is_generator PE B -> inclF B PE.
Proof. intros B HB; rewrite HB; apply span_inclF_diag. Qed.

Lemma is_generator_nil : forall (B : 'E^0), is_generator zero_sub_struct B.
Proof. intros; unfold is_generator; rewrite span_nil; easy. Qed.

Lemma is_generator_nonnil :
  forall (B : 'E^n), is_generator PE B -> PE <> zero_sub_struct -> B <> 0.
Proof. move=>> HB HPE; contradict HPE; rewrite HB HPE span_zero; easy. Qed.

(* FC: useless? *)
Lemma is_generator_1 :
  forall (x0 : E), is_generator (in_line x0) (singleF x0).
Proof. easy. Qed.

(* FC: useless? *)
Lemma is_generator_2 :
  forall (x0 x1 : E), is_generator (in_plane x0 x1) (coupleF x0 x1).
Proof. easy. Qed.

(* FC: useless? *)
Lemma is_generator_3 :
  forall (x0 x1 x2 : E),
    is_generator (in_3d_space x0 x1 x2) (tripleF x0 x1 x2).
Proof. easy. Qed.

Lemma is_generator_coupleF_sym :
  forall (x0 x1 : E),
    is_generator PE (coupleF x0 x1) -> is_generator PE (coupleF x1 x0).
Proof.
intros x0 x1; unfold is_generator; fold (in_plane x0 x1).
rewrite span_coupleF_sym; easy.
Qed.

Lemma is_generator_monot :
  forall (B1 : 'E^n1) (B2 : 'E^n2),
    invalF B1 B2 -> inclF B2 PE -> is_generator PE B1 -> is_generator PE B2.
Proof.
move=>> HB HB2 HB1; rewrite HB1; apply subset_ext_equiv; split.
apply span_monot; easy. apply span_incl; rewrite -HB1; easy.
Qed.

Lemma is_generator_equiv :
  forall (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B1 (span B2) -> inclF B2 (span B1) ->
    is_generator PE B1 <-> is_generator PE B2.
Proof. intros; unfold is_generator; rewrite (span_eq _ B2); easy. Qed.

Lemma is_generator_castF_equiv :
  forall (H : n1 = n2) (B1 : 'E^n1),
    is_generator PE (castF H B1) <-> is_generator PE B1.
Proof. intros; unfold is_generator; rewrite span_castF_compat; easy. Qed.

Lemma castF_is_generator_compat :
  forall (H : n1 = n2) (B1 : 'E^n1),
    is_generator PE B1 -> is_generator PE (castF H B1).
Proof. apply is_generator_castF_equiv. Qed.

Lemma castF_is_generator_reg :
  forall (H : n1 = n2) (B1 : 'E^n1),
    is_generator PE (castF H B1) -> is_generator PE B1.
Proof. apply is_generator_castF_equiv. Qed.

Lemma is_generator_concatF_sym :
  forall (B1 : 'E^n1) (B2 : 'E^n2),
    is_generator PE (concatF B1 B2) -> is_generator PE (concatF B2 B1).
Proof. intros B1 B2 HB; rewrite HB; apply span_concatF_sym. Qed.

Lemma is_generator_concatF_compat_l :
  forall (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B1 PE -> is_generator PE B2 -> is_generator PE (concatF B1 B2).
Proof.
intros B1 B2 HB1 HB2; rewrite HB2; apply span_concatF_compat_l.
rewrite <- HB2; easy.
Qed.

Lemma is_generator_concatF_compat_r :
  forall (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B2 PE -> is_generator PE B1 -> is_generator PE (concatF B1 B2).
Proof.
intros B1 B2 HB2 HB1; rewrite HB1; apply span_concatF_compat_r.
rewrite <- HB1; easy.
Qed.

Lemma is_generator_zero_closed : forall (B : 'E^n), is_generator PE B -> PE 0.
Proof. intros B HB; rewrite HB; apply span_zero_closed. Qed.

Lemma is_generator_plus_closed :
  forall (B : 'E^n), is_generator PE B -> plus_closed PE.
Proof. intros B HB; rewrite HB; apply span_plus_closed. Qed.

Lemma is_generator_opp_closed :
  forall (B : 'E^n), is_generator PE B -> opp_closed PE.
Proof. intros B HB; rewrite HB; apply span_opp_closed. Qed.

Lemma is_generator_minus_closed :
  forall (B : 'E^n), is_generator PE B -> minus_closed PE.
Proof. intros B HB; rewrite HB; apply span_minus_closed. Qed.

Lemma is_generator_scal_closed :
  forall (B : 'E^n), is_generator PE B -> scal_closed PE.
Proof. intros B HB; rewrite HB; apply span_scal_closed. Qed.

Lemma is_generator_compatible_ms :
   forall (B : 'E^n), is_generator PE B -> compatible_ms PE.
Proof. intros B HB; rewrite HB; apply span_compatible_ms. Qed.

Lemma is_generator_comb_lin_closed :
  forall (B : 'E^n), is_generator PE B -> comb_lin_closed PE.
Proof. intros B HB; rewrite HB; apply span_comb_lin_closed. Qed.

Lemma is_generator_ex_decomp :
  forall (B : 'E^n), is_generator PE B -> comb_lin_surjL PE B.
Proof. intros B HB; rewrite HB; apply span_ex_decomp. Qed.

Lemma ex_decomp_is_generator :
  forall (B : 'E^n),
    compatible_ms PE -> inclF B PE -> comb_lin_surjL PE B -> is_generator PE B.
Proof.
intros B HB1 HB2 HB3; apply subset_ext_equiv; split.
intros x Hx; destruct (HB3 _ Hx) as [L HL]; rewrite HL; easy.
intros _ [L]; apply compatible_ms_comb_lin; easy.
Qed.

Lemma uniq_decomp_is_generator :
  forall (B : 'E^n),
    compatible_ms PE -> inclF B PE -> comb_lin_bijL PE B -> is_generator PE B.
Proof.
intros; apply ex_decomp_is_generator; try apply comb_lin_bijL_surjL; easy.
Qed.

Lemma is_generator_fullset_compat_gen :
  forall (HPE : compatible_ms PE) (B : 'E^n) (HB : inclF B PE),
    let PE_sub := @fullset (sub_ms HPE) in
    let B_sub i := mk_sub_ms _ _ (HB i) in
    is_generator PE B -> is_generator PE_sub B_sub.
Proof.
move=>> HB; apply subset_ext_equiv; split; try easy.
intros [x Hx] _; destruct (is_generator_ex_decomp _ HB x Hx) as [L HL].
apply span_ex; exists L; apply val_inj; rewrite val_comb_lin; easy.
Qed.

Lemma is_generator_fullset_compat :
  forall (B : 'E^n) (HB : is_generator PE B),
    let HB1 := is_generator_inclF _ HB in
    let HPE := is_generator_compatible_ms _ HB in
    let PE_sub := @fullset (sub_ms HPE) in
    let B_sub i := mk_sub_ms _ _ (HB1 i) in
    is_generator PE_sub B_sub.
Proof. intros; apply is_generator_fullset_compat_gen; easy. Qed.

End Generator_Facts.


Section Free_Facts.

(** Properties of is_lin_dep/is_free. *)

Context {K : Ring}.
Context {E : ModuleSpace K}.

Hypothesis HK : nonzero_struct K.

Lemma is_lin_dep_ex :
  forall {n} (B : 'E^n),
    is_lin_dep B <-> exists L, comb_lin L B = 0 /\ L <> 0.
Proof.
intros n B; split; intros HB.
destruct (not_all_ex_not _ _ HB) as [L HL]; exists L; apply imply_to_and; easy.
destruct HB as [L [HL1 HL2]]; apply ex_not_not_all; exists L; intros; auto.
Qed.

(** Establish first the property on is_lin_dep. *)

Lemma with_zero_is_lin_dep : forall {n} (B : 'E^n), inF 0 B -> is_lin_dep B.
Proof.
intros n B [i Hi]; apply is_lin_dep_ex; exists (kron _ i); split.
rewrite comb_lin_kron_in_r; easy.
apply neqF; exists i; rewrite kron_is_1; try easy.
apply one_not_zero; easy.
Qed.

Lemma is_lin_dep_zero : forall {n}, is_lin_dep (0 : 'E^n.+1).
Proof. move=>>; apply with_zero_is_lin_dep; exists ord0; easy.  Qed.

Lemma is_lin_dep_zero_rev :
  forall {n}, is_lin_dep (0 : 'E^n) -> (0 < n)%coq_nat.
Proof.
move=>> /is_lin_dep_ex [L [_ /neqF_rev [i _]]].
apply Nat.neq_0_lt_0; contradict i; rewrite i; intros [j Hj]; easy.
Qed.

Lemma is_lin_dep_zero_equiv :
  forall {n}, is_lin_dep (0 : 'E^n) <-> (0 < n)%coq_nat.
Proof.
intros; split. apply is_lin_dep_zero_rev.
destruct n as [| n]; try easy; intros _; apply is_lin_dep_zero.
Qed.

Lemma not_injF_is_lin_dep :
  forall {n} (B : 'E^n), ~ injective B -> is_lin_dep B.
Proof.
move=> n B /not_all_ex_not [i0 /not_all_ex_not [i1 H]].
destruct n; try now destruct i0.
apply imply_to_and in H; destruct H as [HB Hi]; apply not_eq_sym in Hi.
destruct n; try now rewrite 2!ord1 in Hi.
rewrite is_lin_dep_ex; exists (kron _ i0 - kron _ i1); split.
(* *)
rewrite comb_lin_plus_l comb_lin_opp_l 2!comb_lin_kron_in_r -HB.
apply: minus_eq_zero.
(* *)
apply neqF; exists i0.
rewrite -> fct_minus_eq, kron_is_1, kron_is_0; try easy.
rewrite minus_zero_r; apply one_not_zero; easy.
apply ord_neq_compat; easy.
Qed.

Lemma castF_is_lin_dep_compat :
  forall {n1 n2} (H : n1 = n2) (B1 : 'E^n1),
    is_lin_dep B1 -> is_lin_dep (castF H B1).
Proof.
intros n1 n2 H B1; rewrite 2!is_lin_dep_ex.
intros [L [HL HL0]]; exists (castF H L); split; try now rewrite comb_lin_castF.
contradict HL0; apply: (castF_zero_reg H); easy.
Qed.

Lemma castF_is_lin_dep_reg :
  forall {n1 n2} (H : n1 = n2) (B1 : 'E^n1),
    is_lin_dep (castF H B1) -> is_lin_dep B1.
Proof.
intros n1 n2 H B1 HB; rewrite -(castF_id _ (sym_eq H) B1).
apply castF_is_lin_dep_compat; easy.
Qed.

Lemma is_lin_dep_castF_equiv :
  forall {n1 n2} (H : n1 = n2) (B1 : 'E^n1),
    is_lin_dep (castF H B1) <-> is_lin_dep B1.
Proof.
intros; split. apply castF_is_lin_dep_reg. apply castF_is_lin_dep_compat.
Qed.

Lemma concatF_is_lin_dep_compat_l :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    is_lin_dep B1 -> is_lin_dep (concatF B1 B2).
Proof.
move=>>; rewrite 2!is_lin_dep_ex; intros [L HL]; exists (concatF L 0); split.
rewrite comb_lin_concatF_zero_lr; easy. apply: concatF_zero_neqF_compat_l; easy.
Qed.

Lemma concatF_is_lin_dep_compat_r :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    is_lin_dep B2 -> is_lin_dep (concatF B1 B2).
Proof.
move=>>; rewrite 2!is_lin_dep_ex; intros [L HL]; exists (concatF 0 L); split.
rewrite comb_lin_concatF_zero_ll; easy. apply: concatF_zero_neqF_compat_r; easy.
Qed.

Lemma not_disj_is_lin_dep_concatF :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2) x,
    inF x B1 -> inF x B2 -> is_lin_dep (concatF B1 B2).
Proof.
intros n1 n2 B1 B2 x [i1 Hx1] [i2 Hx2]; apply not_injF_is_lin_dep.
assert (Hf : (first_ord n2 i1 < n1)%coq_nat) by now apply /ltP; simpl.
assert (Hl : ~ (last_ord n1 i2 < n1)%coq_nat)
    by (apply Nat.nlt_ge; apply /leP; apply leq_addr).
apply ex_not_not_all; exists (first_ord n2 i1).
apply ex_not_not_all; exists (last_ord n1 i2).
rewrite not_imp_and_equiv; split; try apply ord_neq; auto with zarith.
rewrite concatF_correct_l concat_l_first
    concatF_correct_r concat_r_last -Hx1; easy.
Qed.

Lemma insertF_is_lin_dep_compat :
  forall {n} (B : 'E^n) x0 i0, is_lin_dep B -> is_lin_dep (insertF B x0 i0).
Proof.
intros n B x0 i0; rewrite 2!is_lin_dep_ex; move=> [L [HL /neqF_rev [i Hi]]].
exists (insertF L 0 i0); split.
rewrite comb_lin_insertF scal_zero_l HL plus_zero_l; easy.
apply neqF; exists (skip_ord i0 i); rewrite insertF_correct; easy.
Qed.

Lemma skipF_is_lin_dep_reg :
  forall {n} (B : 'E^n.+1) i0, is_lin_dep (skipF B i0) -> is_lin_dep B.
Proof.
intros n B i0; rewrite -{2}(insertF_skipF B i0).
apply insertF_is_lin_dep_compat.
Qed.

Lemma in_line_is_lin_dep :
  forall {n} (B : 'E^n) {i j}, i <> j -> in_line (B i) (B j) -> is_lin_dep B.
Proof.
move=> n B i j Hi /span_EX [Lj HLj]; apply is_lin_dep_ex;
    exists (kron _ j - scal (Lj ord0) (kron _ i)); split.
(* *)
rewrite comb_lin_minus_l comb_lin_scal_l 2!comb_lin_kron_in_r HLj.
rewrite comb_lin_1; apply: minus_eq_zero.
(* *)
apply neqF; exists j.
rewrite -> fct_minus_eq, fct_scal_eq, kron_is_1, kron_is_0; try easy.
rewrite scal_zero_r minus_zero_r; apply one_not_zero; easy.
intros; contradict Hi; apply ord_inj; easy.
Qed.

Lemma in_plane_is_lin_dep :
  forall {n} (B : 'E^n) {i j k},
    i <> k -> j <> k -> in_plane (B i) (B j) (B k) -> is_lin_dep B.
Proof.
move=> n B i j k Hi Hj /span_EX [Lk HLk]; apply is_lin_dep_ex;
  exists (kron _ k
      - scal (Lk ord0) (kron _ i) - scal (Lk ord_max) (kron _ j)); split.
(* *)
rewrite 2!comb_lin_minus_l 2!comb_lin_scal_l 3!comb_lin_kron_in_r HLk.
rewrite comb_lin_2 coupleF_0 coupleF_1; apply: minus2_eq_zero.
(* *)
apply neqF; exists k.
rewrite -> 2!fct_minus_eq, 2!fct_scal_eq,
    kron_is_1, 2!kron_is_0; try apply ord_neq_compat; try easy.
rewrite 2!scal_zero_r 2!minus_zero_r; apply one_not_zero; easy.
Qed.

Lemma is_free_without_zero : forall {n} (B : 'E^n), is_free B -> ~ inF 0 B.
Proof. move=>>; rewrite contra_not_r_equiv; apply with_zero_is_lin_dep. Qed.

Lemma is_free_zero_rev : forall {n}, is_free (0 : 'E^n) -> n = O.
Proof.
intros n; rewrite -nat_leq_0 -Nat.nlt_ge contra_not_r_equiv.
destruct n as [| n]; try easy; intros _; apply is_lin_dep_zero.
Qed.

Lemma is_free_zero_equiv : forall {n}, is_free (0 : 'E^n) <-> n = O.
Proof.
move=>>; rewrite -nat_leq_0 -Nat.nlt_ge iff_not_r_equiv.
apply is_lin_dep_zero_equiv.
Qed.

Lemma is_free_nil_or_nonzero :
  forall {n} (B : 'E^n), is_free B -> n = O \/ B <> 0.
Proof.
intros n; destruct n as [| n]. intros; left; easy.
move=>> HB; right; contradict HB; rewrite HB; apply is_lin_dep_zero.
Qed.

Lemma is_free_nonzero : forall {n} (B : 'E^n.+1), is_free B -> B <> 0.
Proof. move=>> /is_free_nil_or_nonzero [H | H]; easy. Qed.

Lemma is_free_nonnil_or_zero :
  forall {n} (B : 'E^n), is_free B -> (0 < n)%coq_nat \/ B = 0.
Proof.
intros n; destruct n as [| n]. intros; right; apply: nil_is_zero.
move=>>; left; auto with arith.
Qed.

Lemma is_free_nonnil :
  forall {n} (B : 'E^n), is_free B -> B <> 0 -> (0 < n)%coq_nat.
Proof. move=>> /is_free_nonnil_or_zero [H | H]; easy. Qed.

Lemma is_free_nonnil_nonzero_equiv :
  forall {n} (B : 'E^n), is_free B -> (0 < n)%coq_nat <-> B <> 0.
Proof.
intros; apply iff_sym; split. apply is_free_nonnil; easy.
destruct n as [| n]; try easy; intros _; apply is_free_nonzero; easy.
Qed.

Lemma is_free_nil_zero_equiv :
  forall {n} (B : 'E^n), is_free B -> n = O <-> B = 0.
Proof.
intros; rewrite -nat_leq_0 iff_not_equiv Nat.nle_gt.
apply is_free_nonnil_nonzero_equiv; easy.
Qed.

Lemma is_free_injF :
  forall {n} (B : 'E^n), is_free B -> injective B.
Proof. move=>>; rewrite contra_equiv; apply not_injF_is_lin_dep. Qed.

Lemma castF_is_free_compat :
  forall {n1 n2} (H : n1 = n2) (B1 : 'E^n1),
    is_free B1 -> is_free (castF H B1).
Proof. move=>>; apply contra_equiv, castF_is_lin_dep_reg. Qed.

Lemma castF_is_free_reg :
  forall {n1 n2} (H : n1 = n2) (B1 : 'E^n1),
    is_free (castF H B1) -> is_free B1.
Proof. move=>>; apply contra_equiv, castF_is_lin_dep_compat. Qed.

Lemma is_free_castF_equiv :
  forall {n1 n2} (H : n1 = n2) (B1 : 'E^n1),
    is_free (castF H B1) <-> is_free B1.
Proof. move=>>; apply iff_not_equiv, is_lin_dep_castF_equiv. Qed.

Lemma concatF_is_free_reg_l :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    is_free (concatF B1 B2) -> is_free B1.
Proof. move=>>; apply contra_equiv; apply concatF_is_lin_dep_compat_l. Qed.

Lemma concatF_is_free_reg_r :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    is_free (concatF B1 B2) -> is_free B2.
Proof. move=>>; apply contra_equiv; apply concatF_is_lin_dep_compat_r. Qed.

Lemma is_free_concatF_disj :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2) x,
    is_free (concatF B1 B2) -> ~ inF x B1 \/ ~ inF x B2.
Proof.
move=>>; rewrite -not_and_equiv contra_not_r_equiv.
intros [H1 H2]; eapply not_disj_is_lin_dep_concatF; [apply H1 | easy].
Qed.

Lemma insertF_is_free_reg :
  forall {n} (B : 'E^n) x0 i0, is_free (insertF B x0 i0) -> is_free B.
Proof. move=>>; rewrite contra_equiv; apply insertF_is_lin_dep_compat. Qed.

Lemma skipF_is_free_compat :
  forall {n} {B : 'E^n.+1} i0, is_free B -> is_free (skipF B i0).
Proof. move=>>; rewrite contra_equiv; apply skipF_is_lin_dep_reg. Qed.

Lemma is_free_not_in_line :
  forall {n} (B : 'E^n),
    is_free B -> forall i j, i <> j -> ~ in_line (B i) (B j).
Proof.
move=>> HB; move=>> Hi H; contradict HB;
    eapply in_line_is_lin_dep; [apply Hi | apply H].
Qed.

Lemma is_free_not_in_plane :
  forall {n} (B : 'E^n),
    is_free B ->
    forall i j k, i <> k -> j <> k -> ~ in_plane (B i) (B j) (B k).
Proof.
move=>> HB; move=>> Hi Hj H; contradict HB;
    eapply in_plane_is_lin_dep; [apply Hi | apply Hj | apply H].
Qed.

(** Establish first the property on is_free. *)

Lemma is_free_uniq_decomp :
  forall {n} (B : 'E^n), is_free B -> comb_lin_injL B.
Proof.
intros n B HB L L' HL%minus_zero_compat.
rewrite -comb_lin_minus_l in HL; apply minus_zero_reg; auto.
Qed.

Lemma uniq_decomp_is_free :
  forall {n} (B : 'E^n), comb_lin_injL B -> is_free B.
Proof.
intros n B HB L HL; apply HB; rewrite (comb_lin_zero_compat_l 0); easy.
Qed.

Lemma is_free_uniq_decomp_equiv :
  forall {n} (B : 'E^n), is_free B <-> comb_lin_injL B.
Proof.
intros; split. apply is_free_uniq_decomp. apply uniq_decomp_is_free.
Qed.

Lemma is_free_nil : forall (B : 'E^0), is_free B.
Proof. intros B L HL; apply eqF; intros [i Hi]; easy. Qed.

Lemma is_free_permutF :
  forall {n} p (B : 'E^n), bijective p -> is_free B -> is_free (permutF p B).
Proof.
intros n p B Hp HB L; rewrite {1}(permutF_f_inv Hp L) comb_lin_permutF;
    try now apply bij_inj.
move=> /HB /eqF_rev HL; apply eqF; intros i.
specialize (HL (p i)); rewrite zeroF in HL; rewrite zeroF -HL.
unfold permutF; rewrite f_inv_correct_l; easy.
Qed.

Lemma is_free_permutF_equiv :
  forall {n} p (B : 'E^n), bijective p -> is_free B <-> is_free (permutF p B).
Proof.
intros n p B Hp; split. apply is_free_permutF; easy.
rewrite <- (permutF_id p (f_inv Hp) B), permutF_id.
apply is_free_permutF, f_inv_bij.
apply f_inv_correct_l.
apply f_inv_correct_r.
Qed.

Lemma not_uniq_decomp_is_lin_dep :
  forall {n} (B : 'E^n), ~ comb_lin_injL B -> is_lin_dep B.
Proof. move=>>; rewrite -contra_equiv; apply is_free_uniq_decomp. Qed.

Lemma is_lin_dep_not_uniq_decomp :
  forall {n} (B : 'E^n), is_lin_dep B -> ~ comb_lin_injL B.
Proof. move=>>; rewrite -contra_equiv; apply uniq_decomp_is_free. Qed.

Lemma is_lin_dep_not_uniq_decomp_equiv :
  forall {n} (B : 'E^n), is_lin_dep B <-> ~ comb_lin_injL B.
Proof. move=>>; apply not_iff_compat, is_free_uniq_decomp_equiv. Qed.

Lemma is_lin_dep_nonnil :
  forall {n} (B : 'E^n), is_lin_dep B -> (0 < n)%coq_nat.
Proof.
move=>>; rewrite contra_not_l_equiv Nat.nlt_ge nat_leq_0.
intros; subst; apply is_free_nil.
Qed.

(** Mixed properties of is_lin_dep/is_free. *)

(* Gostiaux T1, Th 6.61 pp. 189-190. (=>) *)
Lemma is_lin_dep_insertF :
  forall {n} (B : 'E^n) x0 i0, span B x0 -> is_lin_dep (insertF B x0 i0).
Proof.
intros n B x0 i0 [L]; apply is_lin_dep_ex; exists (insertF L (- 1%K) i0); split.
rewrite comb_lin_insertF scal_opp_l scal_one; apply: plus_opp_l.
rewrite -(insertF_zero i0); apply insertF_neqF_compat_r.
apply one_not_zero in HK; contradict HK; apply opp_inj; rewrite opp_zero; easy.
Qed.

Lemma is_free_insertF_rev :
  forall {n} (B : 'E^n) x0 i0, is_free (insertF B x0 i0) -> ~ span B x0.
Proof. move=>>; rewrite contra_not_r_equiv; apply is_lin_dep_insertF. Qed.

Lemma is_free_fullset_compat :
  forall (PE : E -> Prop) (HPE : compatible_ms PE)
      {n} (B : 'E^n) (HB : inclF B PE),
    let PE_sub := @fullset (sub_ms HPE) in
    let B_sub i := mk_sub_ms HPE _ (HB i) in
    is_free B -> inclF B_sub PE_sub /\ is_free B_sub.
Proof.
move=>> HB2; split; try easy; intros L HL; apply HB2.
rewrite mk_sub_comb_lin in HL; apply mk_sub_inj in HL; easy.
Qed.

Lemma is_free_sub_ms_equiv :
  forall (PE : E -> Prop) (HPE : compatible_ms PE)
      {n} (B : '(sub_ms HPE)^n),
    let B_val i := val (B i) in
    is_free B <-> is_free B_val.
Proof.
intros PE HPE n B B_val; split; intros HB L HL; apply HB.
apply val_inj; rewrite val_comb_lin; easy.
rewrite -val_comb_lin HL; easy.
Qed.

End Free_Facts.


Section Basis_Facts1.

(** Properties of is_basis (from those of is_generator and is_free). *)

Context {K : Ring}.
Context {E : ModuleSpace K}.

Hypothesis HK : nonzero_struct K.

Variable PE : E -> Prop.

Context {n n1 n2 : nat}.

Variable B : 'E^n.
Variable B1 : 'E^n1.
Variable B2 : 'E^n2.

Lemma is_basis_span_equiv : is_basis (span B) B <-> is_free B.
Proof.
assert (H : forall P Q R : Prop, P -> Q <-> R -> P /\ Q <-> R) by tauto.
intros; apply H; easy.
Qed.

Lemma is_basis_injF : is_basis PE B -> injective B.
Proof. intros [_ HB]; apply is_free_injF; easy. Qed.

Lemma is_basis_castF_equiv :
  forall (H : n1 = n2), is_basis PE (castF H B1) <-> is_basis PE B1.
Proof.
intros; unfold is_basis;
    rewrite is_generator_castF_equiv is_free_castF_equiv; easy.
Qed.

Lemma castF_is_basis_compat :
  forall (H : n1 = n2), is_basis PE B1 -> is_basis PE (castF H B1).
Proof. apply is_basis_castF_equiv. Qed.

Lemma castF_is_basis_reg :
  forall (H : n1 = n2), is_basis PE (castF H B1) -> is_basis PE B1.
Proof. apply is_basis_castF_equiv. Qed.

Lemma is_basis_is_generator : is_basis PE B -> is_generator PE B.
Proof. intros [H _]; easy. Qed.

Lemma is_basis_is_free : is_basis PE B -> is_free B.
Proof. intros [_ H]; easy. Qed.

Lemma is_basis_inclF : is_basis PE B -> inclF B PE.
Proof. intros [HB _]; apply is_generator_inclF; easy. Qed.

Lemma is_basis_zero_closed : is_basis PE B -> PE 0.
Proof. intros [HB _]; apply (is_generator_zero_closed _ B HB). Qed.

Lemma is_basis_plus_closed : is_basis PE B -> plus_closed PE.
Proof. intros [HB _]; apply (is_generator_plus_closed _ B HB). Qed.

Lemma is_basis_opp_closed : is_basis PE B -> opp_closed PE.
Proof. intros  [HB _]; apply (is_generator_opp_closed _ B HB). Qed.

Lemma is_basis_minus_closed : is_basis PE B -> minus_closed PE.
Proof. intros [HB _]; apply (is_generator_minus_closed _ B HB). Qed.

Lemma is_basis_scal_closed : is_basis PE B -> scal_closed PE.
Proof. intros [HB _]; apply (is_generator_scal_closed _ B HB). Qed.

Lemma is_basis_compatible_ms : is_basis PE B -> compatible_ms PE.
Proof. intros [HB _]; apply (is_generator_compatible_ms _ B HB). Qed.

Lemma is_basis_comb_lin_closed : is_basis PE B -> comb_lin_closed PE.
Proof. intros [HB _]; apply (is_generator_comb_lin_closed _ B HB). Qed.

Lemma is_basis_ex_decomp : is_basis PE B -> comb_lin_surjL PE B.
Proof. intros [HB _]; apply is_generator_ex_decomp; easy. Qed.

Lemma is_basis_uniq_decomp : is_basis PE B -> comb_lin_injL B.
Proof. intros [_ HB]; apply is_free_uniq_decomp; easy. Qed.

Theorem is_basis_ex_uniq_decomp : is_basis PE B -> comb_lin_bijL PE B.
Proof.
intros; apply comb_lin_surjL_injL_bijL.
apply is_basis_ex_decomp; easy. apply is_basis_uniq_decomp; easy.
Qed.

Theorem ex_uniq_decomp_is_basis :
  compatible_ms PE -> inclF B PE -> comb_lin_bijL PE B -> is_basis PE B.
Proof.
intros HB; split.
apply uniq_decomp_is_generator; easy.
apply uniq_decomp_is_free, (comb_lin_bijL_injL PE); easy.
Qed.

Lemma is_basis_ex_uniq_decomp_equiv :
  compatible_ms PE -> inclF B PE -> is_basis PE B <-> comb_lin_bijL PE B.
Proof.
intros; split.
apply is_basis_ex_uniq_decomp. apply ex_uniq_decomp_is_basis; easy.
Qed.

Lemma is_basis_fullset_compat_gen :
  forall (HPE : compatible_ms PE) (HB : inclF B PE),
    let PE_sub := @fullset (sub_ms HPE) in
    let B_sub i := mk_sub_ms _ _ (HB i) in
    is_basis PE B -> is_basis PE_sub B_sub.
Proof.
move=>> [HB1 HB2]; split.
apply is_generator_fullset_compat_gen; easy.
apply is_free_fullset_compat; easy.
Qed.

Lemma is_basis_fullset_compat :
  forall (HB : is_basis PE B),
    let HB1 := is_basis_inclF HB in
    let HPE := is_basis_compatible_ms HB in
    let PE_sub := @fullset (sub_ms HPE) in
    let B_sub i := mk_sub_ms _ _ (HB1 i) in
    is_basis PE_sub B_sub.
Proof. intros; apply is_basis_fullset_compat_gen; easy. Qed.

End Basis_Facts1.


Section Basis_Facts2.

(** More properties of is_basis (from those of is_generator and is_free). *)

Context {K : Ring}.
Context {E : ModuleSpace K}.

Hypothesis HK : nonzero_struct K.

Variable PE : E -> Prop.

Lemma is_basis_nil : forall (B : 'E^0), is_basis zero_sub_struct B.
Proof. intros; split; [apply is_generator_nil | apply is_free_nil]. Qed.

Lemma is_basis_nonzero : forall {n} (B : 'E^n.+1), is_basis PE B -> B <> 0.
Proof. move=>> [_ /(is_free_nonzero HK) HB]; easy. Qed.

Lemma is_basis_nonzero_rev :
  forall {n} (B : 'E^n), is_basis PE B -> B <> 0 -> (0 < n)%coq_nat.
Proof. move=>> [_ HB1] HB2; apply (is_free_nonnil _ HB1 HB2). Qed.

Lemma is_basis_nonzero_equiv :
  forall {n} (B : 'E^n), is_basis PE B -> B <> 0 <-> (0 < n)%coq_nat.
Proof.
intros n B HB; split. apply is_basis_nonzero_rev; easy.
intros; destruct n as [| n]; try apply is_basis_nonzero; easy.
Qed.

Lemma is_basis_nonempty : forall {n} (B : 'E^n), is_basis PE B -> nonempty PE.
Proof. move=>> /is_basis_compatible_ms; apply compatible_ms_nonempty. Qed.

Lemma is_basis_nonzero_sub_struct :
  forall {n} (B : 'E^n.+1), is_basis PE B -> PE <> zero_sub_struct.
Proof.
move=> n B [/is_generator_inclF HB /(is_free_nonzero HK) /neqF_rev [i Hi]].
apply nonzero_sub_struct_ex; exists (B i); easy.
Qed.

Lemma is_basis_nonzero_sub_struct_rev :
  forall {n} (B : 'E^n), is_basis PE B -> PE <> zero_sub_struct -> (0 < n)%coq_nat.
Proof.
move=>> HB /nonzero_sub_struct_ex HPE; specialize (HPE (is_basis_nonempty _ HB)).
apply (is_basis_nonzero_rev _ HB); contradict HPE; rewrite HPE in HB.
intros [x [Hx Hx2]]; contradict Hx2.
destruct (is_basis_ex_decomp _ _ HB x Hx) as [L HL].
rewrite HL comb_lin_zero_r; easy.
Qed.

Lemma is_basis_nonzero_sub_struct_equiv :
  forall {n} (B : 'E^n), is_basis PE B -> PE <> zero_sub_struct <-> (0 < n)%coq_nat.
Proof.
intros n B HB; split. apply (is_basis_nonzero_sub_struct_rev _ HB).
intros; destruct n as [| n]; try apply (is_basis_nonzero_sub_struct B); easy.
Qed.

End Basis_Facts2.


Section Dim_Facts.

(** Properties of has_dim (from those of is_basis). *)

Context {K : Ring}.
Context {E : ModuleSpace K}.

Hypothesis HK : nonzero_struct K.

Variable PE : E -> Prop.

Context {n : nat}.

Lemma has_dim_nonempty : has_dim PE n -> nonempty PE.
Proof. intros [B HB]; apply (is_basis_nonempty _ _ HB). Qed.

Lemma has_dim_nonzero_sub_struct : has_dim PE n.+1 -> PE <> zero_sub_struct.
Proof. intros [B HB]; apply (is_basis_nonzero_sub_struct HK _ _ HB). Qed.

Lemma has_dim_nonzero_sub_struct_rev :
  has_dim PE n -> PE <> zero_sub_struct -> (0 < n)%coq_nat.
Proof. intros [B HB]; apply (is_basis_nonzero_sub_struct_rev _ _ HB). Qed.

Lemma has_dim_nonzero_sub_struct_equiv :
  has_dim PE n -> PE <> zero_sub_struct <-> (0 < n)%coq_nat.
Proof. intros [B HB]; apply (is_basis_nonzero_sub_struct_equiv HK _ _ HB). Qed.

Lemma has_dim_zero_closed : has_dim PE n -> PE 0.
Proof. intros [B HB]; apply (is_basis_zero_closed _ B HB). Qed.

Lemma has_dim_plus_closed : has_dim PE n -> plus_closed PE.
Proof. intros [B HB]; apply (is_basis_plus_closed _ B HB). Qed.

Lemma has_dim_opp_closed : has_dim PE n -> opp_closed PE.
Proof. intros [B HB]; apply (is_basis_opp_closed _ B HB). Qed.

Lemma has_dim_minus_closed : has_dim PE n -> minus_closed PE.
Proof. intros [B HB]; apply (is_basis_minus_closed _ B HB). Qed.

Lemma has_dim_scal_closed : has_dim PE n -> scal_closed PE.
Proof. intros [B HB]; apply (is_basis_scal_closed _ B HB). Qed.

Lemma has_dim_compatible_ms : has_dim PE n -> compatible_ms PE.
Proof. intros [B HB]; apply (is_basis_compatible_ms _ B HB). Qed.

Lemma has_dim_comb_lin_closed : has_dim PE n -> comb_lin_closed PE.
Proof. intros [B HB]; apply (is_basis_comb_lin_closed _ B HB). Qed.

Lemma has_dim_fullset_compat_gen :
  forall (HPE : compatible_ms PE),
    let PE_sub := @fullset (sub_ms HPE) in
    has_dim PE n -> has_dim PE_sub n.
Proof.
move=>> [B HB]; eexists.
apply (is_basis_fullset_compat_gen _ B _ (is_basis_inclF _ _ HB)); easy.
Qed.

Lemma has_dim_fullset_compat :
  forall (HPE : has_dim PE n),
    let PE_sub := @fullset (sub_ms (has_dim_compatible_ms HPE)) in
    has_dim PE_sub n.
Proof. intros; apply has_dim_fullset_compat_gen; easy. Qed.

Lemma has_dim_0 : has_dim (@zero_sub_struct E) 0.
Proof. apply (Dim _ _ (fun _ : 'I_0 => 0)), is_basis_nil. Qed.

Lemma has_dim_0_rev : has_dim PE 0 -> PE = zero_sub_struct.
Proof. intros [B [HB1 HB2]]; rewrite HB1; apply span_nil. Qed.

Lemma has_dim_0_equiv : has_dim PE 0 <-> PE = zero_sub_struct.
Proof.
split. apply has_dim_0_rev. intros HPE; rewrite HPE; apply has_dim_0.
Qed.

Lemma has_dim_Rn : has_dim (@fullset 'R^n) n.
Proof.
apply (Dim _ _ (fun i j : 'I_n => kronecker i j)); split.
apply subset_ext_equiv; split; try easy; intros x _.
rewrite (comb_lin_kronecker_basis x); easy.
intros L HL; rewrite <- comb_lin_kronecker_basis in HL; easy.
Qed.

(* TODO FC (01/03/2023): Ã©noncer ce lemme avec p et H : n=p. *)
Lemma is_free_has_dim_span :
  forall (B : 'E^n), is_free B -> has_dim (span B) n.
Proof. intros B HB; apply (Dim _ _ B), is_basis_span_equiv; easy. Qed.

End Dim_Facts.


Section Linear_mapping_Facts1.

Context {K : Ring}.
Context {E F : ModuleSpace K}.

Variable f : E -> F.
(* TODO FC: next hypothesis is too strong,
  it should be enough to have f linear on PE. *)
Hypothesis Hf : is_linear_mapping f.

Variable PE : E -> Prop.
Hypothesis HPE : compatible_ms PE.

Lemma is_linear_mapping_is_free_compat :
  forall {n} (B : 'E^n),
    is_inj PE (image f PE) f -> (forall i, PE (B i)) ->
    is_free B -> is_free (mapF f B).
Proof.
intros n B H1 H2 H3 L HL.
rewrite <- linear_mapping_comb_lin_compat in HL; try easy.
apply H3.
apply H1.
apply compatible_ms_comb_lin; try easy.
apply compatible_ms_zero; easy.
rewrite is_linear_mapping_zero; easy.
Qed.

Lemma is_linear_mapping_is_generator_compat :
  forall {n} (B : 'E^n),
    (forall i, PE (B i)) ->
    is_generator PE B -> is_generator (image f PE) (mapF f B).
Proof.
intros n B H1 H2.
apply subset_ext_equiv; split; intros x Hx.
(* *)
induction Hx as [y Hy].
rewrite H2 in Hy.
destruct Hy as [L].
rewrite linear_mapping_comb_lin_compat; easy.
(* *)
destruct Hx as [L].
rewrite <- linear_mapping_comb_lin_compat; try easy.
apply Im.
apply compatible_ms_comb_lin; try easy.
Qed.

Lemma is_linear_mapping_is_basis_compat :
  forall n (B : 'E^n),
    is_inj PE (image f PE) f -> (forall i, PE (B i)) ->
    is_basis PE B -> is_basis (image f PE) (mapF f B).
Proof.
move=>> Hf1 HB1 [HB2 HB3]; split.
apply is_linear_mapping_is_generator_compat; easy.
apply is_linear_mapping_is_free_compat; easy.
Qed.

End Linear_mapping_Facts1.


Section Linear_mapping_Facts2.

Context {K : Ring}.
Context {E F : ModuleSpace K}.

Variable f : E -> F.
Hypothesis Hf : is_linear_mapping f.

Variable PE : E -> Prop.
Hypothesis HPE : compatible_ms PE.

(* TODO FC (18/10/2023): we need this lemma! *)
Lemma is_linear_mapping_is_basis_compat_equiv :
  forall n (B : 'E^n),
    is_bij PE (image f PE) f (* is_inj ? *) -> (forall i, PE (B i)) ->
    is_basis PE B <-> is_basis (image f PE) (fun i => f (B i)).
Proof.
intros n B Hf1 HB1; split.
(* *)
apply is_bij_equiv in Hf1; try apply inhabited_ms.
apply is_linear_mapping_is_basis_compat; easy.
(* *)
intros HB2.
apply is_bij_id_is_bij in Hf1; try apply inhabited_ms.
destruct Hf1 as [g Hf1].
replace PE with (image g (image f PE)).
replace B with (fun i => g (f (B i))).
apply is_linear_mapping_is_basis_compat; try easy.

admit. (* But, how to get that? It would be OK with linearity only on the subspace...
YES, do it man!
("@Sg E PE" provides the cup for the coffee...) *)

Admitted.

End Linear_mapping_Facts2.


Local Open Scope R_scope.
Local Open Scope Monoid_scope.
Local Open Scope Group_scope.


Section Free_R_Facts.

(** Properties of is_lin_dep/is_free on R module spaces. *)

(** Establish first the property on is_lin_dep. *)

Context {E : ModuleSpace R_Ring}.

Lemma is_lin_dep_monot :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    injective B1 -> invalF B1 B2 -> is_lin_dep B1 -> is_lin_dep B2.
Proof.
intros n1 n2 B1 B2; destruct (classic (injective B2)) as [HB2 | HB2].
(* *)
rewrite 2!is_lin_dep_ex; intros HB1 HB [L1 [HL1a HL1b]].
destruct (comb_lin_invalF_injF L1 _ _ HB1 HB2 HB) as [L2 [HL2a [HL2b _]]].
exists L2; split; try now rewrite -HL2a.
destruct (neqF_rev _ _ HL1b) as [i1 Hi1], (invalF_fun HL2b) as [f Hf1].
apply neqF; exists (f i1); rewrite -Hf1; easy.
(* *)
intros _ _ _; apply not_injF_is_lin_dep; try easy.
apply nonzero_struct_R.
Qed.

Lemma is_lin_dep_equiv_injF :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    injective B1 -> injective B2 -> invalF B1 B2 -> invalF B2 B1 ->
    is_lin_dep B1 <-> is_lin_dep B2.
Proof. intros; split; apply is_lin_dep_monot; easy. Qed.

Lemma is_lin_dep_1_equiv : forall (B : 'E^1), is_lin_dep B <-> B ord0 = 0.
Proof.
move=>>; split.
(* *)
rewrite is_lin_dep_ex; move=> [L [HL /neqF_rev [i Hi]]]; rewrite ord1 in Hi.
rewrite comb_lin_1 in HL; apply (scal_zero_reg_r_R (L ord0)); easy.
(* *)
intros; apply with_zero_is_lin_dep; try now exists ord0.
apply nonzero_struct_R.
Qed.

Lemma is_lin_dep_singleF_equiv :
  forall (x0 : E), is_lin_dep (singleF x0) <-> x0 = 0.
Proof. intros; rewrite is_lin_dep_1_equiv singleF_0; easy. Qed.

Lemma is_lin_dep_2_equiv :
  forall (B : 'E^2),
    is_lin_dep B <-> B ord0 = 0 \/ in_line (B ord0) (B ord_max).
Proof.
move=>>; split.
(* *)
move=> /is_lin_dep_ex [L [HL HL0]]; rewrite comb_lin_2 in HL.
destruct (Req_dec (L ord_max) 0) as [HL0' | HL0']; [left | right].
(* . *)
rewrite HL0' scal_zero_l plus_zero_r in HL.
apply scal_zero_rev_R in HL; destruct HL as [HL | HL]; try easy.
contradict HL0; apply eqF; intros i;
    destruct (ord2_dec i) as [Hi | Hi]; rewrite Hi; easy.
(* . *)
apply span_ex; exists (singleF (- (/ L ord_max) * (L ord0))).
rewrite comb_lin_1 2!singleF_0.
apply (scal_reg_r_R (L ord_max)); try easy.
rewrite plus_comm in HL. (* was: apply plus_is_zero_l in HL; rewrite -> HL. *)
generalize HL; clear HL; move=> /plus_is_zero_l HL; rewrite -> HL.
rewrite <- scal_opp_l, scal_assoc; f_equal.
unfold opp, mult; simpl; field; easy.
(* *)
move=> [HB | HB].
apply with_zero_is_lin_dep; try now exists ord0. apply nonzero_struct_R.
apply (in_line_is_lin_dep nonzero_struct_R _ ord_0_not_max HB).
Qed.

Lemma is_lin_dep_coupleF_equiv :
  forall (x0 x1 : E),
    is_lin_dep (coupleF x0 x1) <-> x0 = 0 \/ in_line x0 x1.
Proof. intros; rewrite is_lin_dep_2_equiv coupleF_0 coupleF_1; easy. Qed.

Lemma is_lin_dep_3_equiv :
  forall (B : 'E^3),
    is_lin_dep B <->
    B ord0 = 0 \/ in_line (B ord0) (B ord_1) \/
        in_plane (B ord0) (B ord_1) (B ord_max).
Proof.
move=>>; split.
(* *)
move=> /is_lin_dep_ex [L [HL HL0]]; rewrite comb_lin_3 in HL.
destruct (Req_dec (L ord_max) 0) as [HL0a | HL0a];
    try rewrite HL0a scal_zero_l plus_zero_r in HL.
destruct (Req_dec (L ord_1) 0) as [HL0b | HL0b];
    try rewrite HL0b scal_zero_l plus_zero_r in HL.
(* . *)
left; apply (scal_zero_reg_r_R (L ord0)); try easy.
contradict HL0; apply eqF; intros i.
destruct (ord3_dec i) as [[Hi | Hi] | Hi]; rewrite Hi; easy.
(* . *)
right; left; apply span_ex; exists (singleF (- / (L ord_1) * (L ord0))).
apply (scal_reg_r_R (L ord_1) _ _ HL0b). (* was: apply: plus_is_zero_r in HL. *)
generalize HL; clear HL; move=> /plus_is_zero_r HL.
rewrite HL comb_lin_1 2!singleF_0 -Ropp_mult_distr_l
    scal_opp_l scal_opp_r scal_assoc mult_assoc
    -{1}(Rmult_1_l (L ord0)) -(Rinv_r (L ord_1)); easy.
(* . *)
right; right; apply span_ex;
    exists (coupleF (- / L ord_max * L ord0) (- / L ord_max * L ord_1)).
apply (scal_reg_r_R (L ord_max) _ _ HL0a). (* was: apply plus_is_zero_r in HL. *)
generalize HL; clear HL; move=> /plus_is_zero_r HL.
rewrite HL opp_plus comb_lin_2 2!coupleF_0 2!coupleF_1.
rewrite scal_distr_l -2!Ropp_mult_distr_l 2!scal_opp_l 2!scal_opp_r
  2!scal_assoc 2!mult_assoc -{1}(Rmult_1_l (L ord0)) -{1}(Rmult_1_l (L ord_1))
  -(Rinv_r (L ord_max)); easy.
(* *)
move=> [HB | [HB | HB]].
apply with_zero_is_lin_dep; try now exists ord0. apply nonzero_struct_R.
apply (in_line_is_lin_dep nonzero_struct_R _ ord_0_not_1 HB).
apply (in_plane_is_lin_dep nonzero_struct_R _ ord_0_not_max ord_1_not_max HB).
Qed.

Lemma is_lin_dep_tripleF_equiv :
  forall (x0 x1 x2 : E),
    is_lin_dep (tripleF x0 x1 x2) <->
    x0 = 0 \/ in_line x0 x1 \/ in_plane x0 x1 x2.
Proof.
intros; rewrite is_lin_dep_3_equiv tripleF_0 tripleF_1 tripleF_2; easy.
Qed.

Lemma is_free_monot :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    injective B1 -> invalF B1 B2 -> is_free B2 -> is_free B1.
Proof. move=>> HB1 HB; apply contra_equiv; apply is_lin_dep_monot; easy. Qed.

Lemma is_free_equiv_injF :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    injective B1 -> injective B2 -> invalF B1 B2 -> invalF B2 B1 ->
    is_free B1 <-> is_free B2.
Proof. intros; split; apply is_free_monot; easy. Qed.

Lemma is_free_1_equiv : forall (B : 'E^1), is_free B <-> B ord0 <> 0.
Proof. intros; apply iff_not_r_equiv, is_lin_dep_1_equiv. Qed.

Lemma is_free_singleF_equiv :
  forall (x0 : E), is_free (singleF x0) <-> x0 <> 0.
Proof. intros; rewrite is_free_1_equiv singleF_0; easy. Qed.

Lemma is_free_2_equiv :
  forall (B : 'E^2),
    is_free B <-> B ord0 <> 0 /\ ~ in_line (B ord0) (B ord_max).
Proof.
intros; rewrite -not_or_equiv; apply iff_not_r_equiv, is_lin_dep_2_equiv.
Qed.

Lemma is_free_coupleF_equiv :
  forall (x0 x1 : E),
    is_free (coupleF x0 x1) <-> x0 <> 0 /\ ~ in_line x0 x1.
Proof. intros; rewrite is_free_2_equiv coupleF_0 coupleF_1; easy. Qed.

Lemma is_free_3_equiv :
  forall (B : 'E^3),
    is_free B <->
    B ord0 <> 0 /\ ~ in_line (B ord0) (B ord_1) /\
        ~ in_plane (B ord0) (B ord_1) (B ord_max).
Proof.
intros; rewrite -not_or3_equiv; apply iff_not_r_equiv, is_lin_dep_3_equiv.
Qed.

Lemma is_free_tripleF_equiv :
  forall (x0 x1 x2 : E),
    is_free (tripleF x0 x1 x2) <->
    x0 <> 0 /\ ~ in_line x0 x1 /\ ~ in_plane x0 x1 x2.
Proof.
intros; rewrite is_free_3_equiv tripleF_0 tripleF_1 tripleF_2; easy.
Qed.

(** Establish first the property on is_free. *)

Lemma is_free_equiv :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    n1 = n2 -> invalF B1 B2 -> invalF B2 B1 ->
    is_free B1 <-> is_free B2.
Proof.
intros n1 n2 B1 B2 Hn HB12 HB21; split; intros HBa;
    generalize (is_free_injF nonzero_struct_R _ HBa); intros HBb.
apply (is_free_monot _ B1); try apply (injF_equiv B1); easy.
apply (is_free_monot _ B2); try apply (injF_equiv B2); easy.
Qed.

Lemma is_free_coupleF_sym :
  forall (x0 x1 : E), is_free (coupleF x0 x1) -> is_free (coupleF x1 x0).
Proof.
intros x0 x1 H; apply (is_free_equiv (coupleF x0 x1)); try easy.
1,2: apply invalF_coupleF_sym.
Qed.

Lemma is_lin_dep_equiv :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    n1 = n2 -> invalF B1 B2 -> invalF B2 B1 ->
    is_lin_dep B1 <-> is_lin_dep B2.
Proof. intros; rewrite -iff_not_equiv; apply is_free_equiv; easy. Qed.

Lemma is_lin_dep_coupleF_sym :
  forall (x0 x1 : E), is_lin_dep (coupleF x0 x1) -> is_lin_dep (coupleF x1 x0).
Proof. move=>>; rewrite -contra_equiv; apply is_free_coupleF_sym. Qed.

(** Mixed properties of is_lin_dep/is_free. *)

(* Gostiaux T1, Th 6.61 pp. 189-190. (<=) *)
Lemma is_lin_dep_insertF_rev :
  forall {n} (B : 'E^n) x0 i0,
    is_free B -> is_lin_dep (insertF B x0 i0) -> span B x0.
Proof.
move=> n B x0 i0 HB /is_lin_dep_ex [L [HL1 HL2]];
    rewrite comb_lin_insertF_r in HL1.
destruct (eq_dec (L i0) 0) as [HL3 | HL3].
(* *)
rewrite HL3 scal_zero_l plus_zero_l in HL1.
apply HB in HL1; contradict HL2.
apply: (eqF_zero_skipF _ i0); easy.
(* *)
assert (HL3' : - L i0 <> 0).
  rewrite -opp_zero; apply opp_neq_compat; easy.
apply span_ex; exists (scal (/ - L i0) (skipF L i0)); symmetry.
apply (scal_reg_r_R (- L i0)); try easy.
rewrite comb_lin_scal_l scal_assoc scal_opp_l; apply plus_is_zero_l.
rewrite (mult_inv_r_R _ HL3') scal_one plus_comm; easy.
Qed.

(* Gostiaux T1, Th 6.61 pp. 189-190. (<=>) *)
Lemma is_lin_dep_insertF_equiv :
  forall {n} (B : 'E^n) x0 i0,
    is_free B -> is_lin_dep (insertF B x0 i0) <-> span B x0.
Proof.
intros; split. apply is_lin_dep_insertF_rev; easy. apply is_lin_dep_insertF.
apply nonzero_struct_R.
Qed.

Lemma is_free_insertF :
  forall {n} (B : 'E^n) x0 i0,
    is_free B -> ~ span B x0 -> is_free (insertF B x0 i0).
Proof.
move=>> HB; rewrite contra_not_l_equiv; apply is_lin_dep_insertF_rev; easy.
Qed.

Lemma is_free_insertF_equiv :
  forall {n} (B : 'E^n) x0 i0,
    is_free B -> is_free (insertF B x0 i0) <-> ~ span B x0.
Proof. move=>>; rewrite iff_not_r_equiv; apply is_lin_dep_insertF_equiv. Qed.

(* Gostiaux T1, Th 6.62 pp. 190-192. *)
Lemma span_S_is_lin_dep :
  forall {n} (B : 'E^n) (C : 'E^n.+1), inclF C (span B) -> is_lin_dep C.
Proof.
move=> n B C /spanF_ex_flipT [L HC]; induction n as [| n IHn].
(* *)
apply is_lin_dep_ex; exists ones; split; try apply ones_not_zero_R.
apply comb_lin_zero_compat_r, eqF; intros i; rewrite HC; apply comb_lin_nil.
(* *)
destruct (classic (L ord0 = 0)) as [HL | HL].
(* . *)
eapply is_lin_dep_ext; try apply (insertF_skipF _ ord_max).
apply insertF_is_lin_dep_compat; rewrite skipF_last; eapply IHn; intros j.
unfold widenF_S; rewrite (HC (widen_S j)).
rewrite (comb_lin_skipF _ _ ord0) HL scal_zero_l plus_zero_l; easy.
(* . *)
destruct (neqF_rev _ _ HL) as [j0 Hj0]; rewrite zeroF in Hj0; clear HL.
generalize (HC j0); rewrite (comb_lin_skipF _ _ ord0); intros HCj0.
apply axpy_equiv_R in HCj0; try easy; rewrite -comb_lin_scal_l in HCj0.
pose (L0 := skipF (L ord0) j0); pose (L1 := skipF L ord0);
    pose (L2 := skipT L ord0 j0).
pose (M0 := scal (/ L ord0 j0) L0);
    pose (M1 i j := - (M0 j * L1 i j0) + L2 i j).
pose (D j := skipF C j0 j - scal (M0 j) (C j0)).
assert (HD : is_lin_dep D).
  apply (IHn (skipF B ord0) _ M1); intros; unfold D, skipF.
  symmetry; rewrite -plus_minus_r_equiv HC (comb_lin_skipF _ _ ord0).
  rewrite HCj0 scal_minus_distr_l -comb_lin_scal_l 2!scal_assoc mult_comm_R.
  rewrite -plus_assoc -comb_lin_opp_l -comb_lin_plus_l; easy.
apply is_lin_dep_ex in HD; destruct HD as [N [HN1 HN2]]; unfold D in HN1.
rewrite comb_lin_minus_r minus_sym -scal_comb_lin_l -scal_opp_l in HN1.
destruct (comb_lin_skipF_ex_l (- comb_lin N M0) N C j0) as [LL [HLL1 [_ HLL2]]].
apply is_lin_dep_ex; exists LL; split; try now rewrite HLL1.
apply (neqxF_reg _ _ j0), (skipF_neqF_reg _ _ j0); rewrite HLL2; easy.
Qed.

Lemma span_gt_is_lin_dep :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    (n1 < n2)%coq_nat -> inclF B2 (span B1) -> is_lin_dep B2.
Proof.
move=>> /ltP Hn HB; apply castF_is_lin_dep_reg with (sym_eq (subnKC Hn)).
eapply is_lin_dep_ext; try (symmetry; apply concatF_splitF).
eapply concatF_is_lin_dep_compat_l, span_S_is_lin_dep; intros i2.
unfold firstF, castF; apply HB.
Qed.

Lemma is_free_le_is_generator :
  forall {n1 n2} (PE : E -> Prop) (B1 : 'E^n1) (B2 : 'E^n2),
    inclF B1 PE -> is_free B1 -> is_generator PE B2 -> (n1 <= n2)%coq_nat.
Proof.
intros n1 n2 PE B1 B2 HB1a HB1b HB2; rewrite HB2 in HB1a.
destruct (lt_dec n2 n1) as [Hn | Hn].
contradict HB1b; apply (span_gt_is_lin_dep _ _ Hn HB1a).
apply Nat.nlt_ge; easy.
Qed.

End Free_R_Facts.


Section Basis_R_Facts1.

(** Properties of is_basis on R module spaces (from those of is_generator and is_free). *)

Context {E : ModuleSpace R_Ring}.

Variable PE : E -> Prop.

Context {n1 n2 : nat}.

Variable B1 : 'E^n1.
Variable B2 : 'E^n2.

Lemma is_free_le_is_basis :
  inclF B1 PE -> is_free B1 -> is_basis PE B2 -> (n1 <= n2)%coq_nat.
Proof.
intros HB1a HB1b [HB2 _]; apply (is_free_le_is_generator PE B1 B2); easy.
Qed.

Lemma is_basis_le_is_generator :
  is_basis PE B1 -> is_generator PE B2 -> (n1 <= n2)%coq_nat.
Proof.
intros [HB1a HB1b] HB2.
apply (is_free_le_is_generator PE B1 B2); try easy.
apply is_generator_inclF; easy.
Qed.

End Basis_R_Facts1.


Section Basis_R_Facts2.

(** More properties of is_basis on R module spaces (from those of is_generator and is_free). *)

Context {E : ModuleSpace R_Ring}.

Variable PE : E -> Prop.

Lemma is_basis_monot :
  forall {n1 n2} (B1 : 'E^n1) (B2 : 'E^n2),
    n1 = n2 -> invalF B1 B2 -> is_basis PE B1 -> is_basis PE B2.
Proof.
intros n1 n2 B1 B2 Hn HB [HB1a HB1b].
move: (is_free_injF nonzero_struct_R _ HB1b) => HB1c.
move: (injF_monot _ _ Hn HB HB1c) => HB2.
move: (invalF_sym _ _ Hn HB1c HB) => HBa.
subst n2; split.
(* *)
apply (is_generator_monot _ B1); try easy.
apply (inclF_monot_l _ B1); try easy.
apply is_generator_inclF; easy.
(* *)
apply (is_free_monot _ B1); easy.
Qed.

Lemma is_basis_1_equiv :
  forall (B : 'E^1), is_basis (span B) B <-> B ord0 <> 0.
Proof. intros; rewrite is_basis_span_equiv; apply is_free_1_equiv. Qed.

Lemma is_basis_singleF_equiv :
  forall (x0 : E), is_basis (in_line x0) (singleF x0) <-> x0 <> 0.
Proof. intros; apply is_basis_1_equiv. Qed.

Lemma is_basis_2_equiv :
  forall (B : 'E^2),
    is_basis (span B) B <-> B ord0 <> 0 /\ ~ in_line (B ord0) (B ord_max).
Proof. intros; rewrite is_basis_span_equiv; apply is_free_2_equiv. Qed.

Lemma is_basis_coupleF_equiv :
  forall (x0 x1 : E),
    is_basis (in_plane x0 x1) (coupleF x0 x1) <->
    x0 <> 0 /\ ~ in_line x0 x1.
Proof. intros; rewrite is_basis_span_equiv; apply is_free_coupleF_equiv. Qed.

Lemma is_basis_3_equiv :
  forall (B : 'E^3),
    is_basis (span B) B <->
    B ord0 <> 0 /\ ~ in_line (B ord0) (B ord_1) /\
        ~ in_plane (B ord0) (B ord_1) (B ord_max).
Proof. intros; rewrite is_basis_span_equiv; apply is_free_3_equiv. Qed.

Lemma is_basis_tripleF_equiv :
  forall (x0 x1 x2 : E),
    is_basis (in_3d_space x0 x1 x2) (tripleF x0 x1 x2) <->
    x0 <> 0 /\ ~ in_line x0 x1 /\ ~ in_plane x0 x1 x2.
Proof. intros; rewrite is_basis_span_equiv; apply is_free_tripleF_equiv. Qed.

End Basis_R_Facts2.


Section Dim_R_Facts1.

(** Properties of has_dim on R module spaces (from those of is_basis). *)

Context {E : ModuleSpace R_Ring}.

Variable PE : E -> Prop.

Lemma has_dim_1 : forall (x0 : E), x0 <> 0 -> has_dim (in_line x0) 1.
Proof. intros x0 H0; apply (Dim _ _ (singleF x0)), is_basis_1_equiv; easy. Qed.

Lemma has_dim_1_rev :
  has_dim PE 1 -> exists x0, x0 <> 0 /\ PE = in_line x0.
Proof.
intros [B [HB1 HB2]]; rewrite HB1; exists (B ord0); split.
apply is_free_1_equiv; easy. apply span_singleF.
Qed.

Lemma has_dim_1_equiv :
  has_dim PE 1 <-> exists x0, x0 <> 0 /\ PE = in_line x0.
Proof.
split. apply has_dim_1_rev.
intros [x0 [H0 H]]; rewrite H; apply has_dim_1; easy.
Qed.

Lemma has_dim_2 :
  forall (x0 x1 : E),
    x0 <> 0 -> ~ in_line x0 x1 -> has_dim (in_plane x0 x1) 2.
Proof.
intros x0 x1 H0 H1; apply (Dim _ _ (coupleF x0 x1)), is_basis_2_equiv;
    rewrite coupleF_0 coupleF_1; easy.
Qed.

Lemma has_dim_2_rev :
  has_dim PE 2 ->
  exists x0 x1, (x0 <> 0 /\ ~ in_line x0 x1) /\ PE = in_plane x0 x1.
Proof.
intros [B [HB1 HB2]]; rewrite HB1; exists (B ord0), (B ord_max); split.
apply is_free_2_equiv; easy. apply span_coupleF.
Qed.

Lemma has_dim_2_equiv :
  has_dim PE 2 <->
  exists x0 x1, (x0 <> 0 /\ ~ in_line x0 x1) /\ PE = in_plane x0 x1.
Proof.
split. apply has_dim_2_rev.
intros [x0 [x1 [H01 H]]]; rewrite H; apply has_dim_2; easy.
Qed.

Lemma has_dim_3 :
  forall (x0 x1 x2 : E),
    x0 <> 0 -> ~ in_line x0 x1 -> ~ in_plane x0 x1 x2 ->
    has_dim (in_3d_space x0 x1 x2) 3.
Proof.
intros x0 x1 x2 H0 H1 H2;
    apply (Dim _ _ (tripleF x0 x1 x2)), is_basis_3_equiv;
    rewrite tripleF_0 tripleF_1 tripleF_2; easy.
Qed.

Lemma has_dim_3_rev :
  has_dim PE 3 ->
  exists x0 x1 x2,
    (x0 <> 0 /\ ~ in_line x0 x1 /\ ~ in_plane x0 x1 x2) /\
      PE = in_3d_space x0 x1 x2.
Proof.
intros [B [HB1 HB2]]; rewrite HB1;
    exists (B ord0), (B ord_1), (B ord_max); split.
apply is_free_3_equiv; easy. apply span_tripleF.
Qed.

Lemma has_dim_3_equiv :
  has_dim PE 3 <->
  exists x0 x1 x2,
    (x0 <> 0 /\ ~ in_line x0 x1 /\ ~ in_plane x0 x1 x2) /\
      PE = in_3d_space x0 x1 x2.
Proof.
split. apply has_dim_3_rev.
intros [x0 [x1 [x2 [H012 H]]]]; rewrite H; apply has_dim_3; easy.
Qed.

End Dim_R_Facts1.


Section Dim_R_Facts2.

(** More properties of has_dim on R module spaces. *)

Context {E : ModuleSpace R_Ring}.

Context {PE : E -> Prop}.

(* Gostiaux T1, Th 6.64 pp. 192-193. *)
Lemma is_generator_has_finite_dim :
  forall {n} (B : 'E^n), is_generator PE B -> exists m, has_dim PE m.
Proof.
intros n B HB.
destruct (nat_has_greatest_element
    (fun m => exists (C : 'E^m), invalF C B /\ is_free C) 0 n)
    as [m [Hm1 [[C [HC1 HC2]] Hm2]]].
(* *)
exists (fun=> 0); split. intros [i Hi]; easy. apply is_free_nil.
(* *)
intros m Hm [C [HC1 HC2]].
assert (Hm' : ~ (m <= n)%coq_nat) by now apply Nat.lt_nge.
contradict Hm'.
apply (is_free_le_is_generator PE C B); try easy.
apply (inclF_monot_l _ B), is_generator_inclF; easy.
(* *)
exists m; apply (Dim _ _ C); split; try easy.
rewrite -> HB, (is_generator_equiv _ _ B).
apply is_generator_span.
apply span_inclF; easy.
intros i; destruct (classic (exists j, B i = C j)) as [[j Hj] | Hi'].
rewrite Hj; apply span_inclF_diag.
specialize (not_ex_all_not _ _ Hi'); simpl; intros Hi; clear Hi'.
assert (H : is_lin_dep (insertF C (B i) ord_max)).
  intros Hi'; generalize (Nat.lt_irrefl m); intros H; contradict H.
  apply Hm2; exists (insertF C (B i) ord_max); split; try easy.
  apply insertF_monot_invalF_l; try easy; exists i; easy.
destruct (is_lin_dep_insertF_rev _ _ _ HC2 H) as [L]; easy.
Qed.

(* Gostiaux T1, Th 6.65 p. 193. *)
Lemma dim_is_unique : (* Also known as dimension theorem. *)
  forall {n1 n2}, has_dim PE n1 -> has_dim PE n2 -> n1 = n2.
Proof.
intros n1 n2 [B1 H1] [B2 H2]; apply Nat.le_antisymm.
(* *)
destruct H1; apply (is_free_le_is_basis PE B1 B2); try easy.
apply is_generator_inclF; easy.
(* *)
destruct H2; apply (is_free_le_is_basis PE B2 B1); try easy.
apply is_generator_inclF; easy.
Qed.

(* Gostiaux T1, Th 6.66 pp. 193-194. *)
Lemma incomplete_basis_theorem : (* Close to Steinitz exchange lemma. *)
  forall {n nf ng} {Bf : 'E^nf} {Bg : 'E^ng},
    has_dim PE n -> inclF Bf PE -> is_free Bf -> is_generator PE Bg ->
    exists m (C : 'E^m), n = (nf + m)%coq_nat /\
      invalF C Bg /\ is_basis PE (concatF Bf C).
Proof.
intros n nf ng Bf Bg [B HB] Hf1 Hf2 Hg.
destruct (nat_has_greatest_element
    (fun m => exists (C : 'E^m), invalF C Bg /\ is_free (concatF Bf C))
      0 (n - nf)%coq_nat) as [m [Hm1 [[C [HC1 HC2]] Hm2]]].
(* *)
exists (fun=> 0); split. intros [i Hi]; easy.
rewrite concatF_nil_r is_free_castF_equiv; easy.
(* *)
intros m Hm; apply all_not_not_ex; intros C [HC1 HC2].
contradict HC2; apply (span_gt_is_lin_dep B).
apply Nat.lt_sub_lt_add_l; easy.
destruct HB as [HB _]; rewrite -HB; apply concatF_lub_inclF; try easy.
rewrite Hg; apply span_inclF; easy.
(* *)
exists m, C.
specialize (Hm2 m.+1); apply (proj1 contra_equiv) in Hm2; auto with arith.
rewrite not_ex_all_not_equiv in Hm2.
assert (H0 : ~ (@ord_max (nf + m) < nf)%coq_nat).
  rewrite ord_max_correct; auto with arith.
assert (H1 : is_basis PE (concatF Bf C)).
  split; try rewrite (is_generator_equiv _ _ Bg); try easy.
  apply concatF_lub_inclF, span_inclF; try rewrite -Hg; easy.
  intros ig; apply is_lin_dep_insertF_rev with ord_max; try easy.
  specialize (Hm2 (insertF C (Bg ig) ord_max)).
  rewrite not_and_equiv -imp_or_equiv in Hm2.
  rewrite (insertF_concatF_r _ _ _ H0).
  replace (concat_r_ord _) with (@ord_max m);
      try apply ord_inj; simpl; auto with arith.
  apply is_lin_dep_castF_equiv, Hm2, insertF_monot_invalF_l; try easy.
  apply inF_refl.
split; try easy.
apply dim_is_unique.
apply (Dim _ _ _ HB).
apply (Dim _ _ _ H1).
Qed.

(* Gostiaux T1, Cor. 6.67 p. 194. *)
Lemma is_free_le_dim :
  forall {n nf} (Bf : 'E^nf),
    has_dim PE n -> inclF Bf PE -> is_free Bf -> (nf <= n)%coq_nat.
Proof.
move=>> [B HB] Hf1 Hf2; apply (is_free_le_is_basis _ _ _ Hf1 Hf2 HB).
Qed.

Lemma gt_dim_is_lin_dep :
  forall {n nf} {Bf : 'E^nf},
    has_dim PE n -> inclF Bf PE -> (n < nf)%coq_nat -> is_lin_dep Bf.
Proof.
move=>> HPE HBf; rewrite contra_not_r_equiv Nat.nlt_ge.
apply is_free_le_dim; easy.
Qed.

(* Gostiaux T1, Cor. 6.67 p. 194. *)
Lemma is_free_dim_is_basis :
  forall {n} {Bf : 'E^n},
    has_dim PE n -> inclF Bf PE -> is_free Bf -> is_basis PE Bf.
Proof.
move=>> HPE Hf1 Hf2; generalize HPE; intros [B [HB _]].
destruct (incomplete_basis_theorem HPE Hf1 Hf2 HB) as [m [C [Hm [_ HC]]]].
apply sym_eq, nat_plus_zero_reg_l in Hm; subst m.
rewrite concatF_nil_r is_basis_castF_equiv in HC; easy.
Qed.

(* Gostiaux T1, Cor. 6.67 p. 194. *)
Lemma is_free_overbasis_ex :
  forall {n nf} {Bf : 'E^nf},
    has_dim PE n -> inclF Bf PE -> is_free Bf ->
    exists (B : 'E^n), invalF Bf B /\ is_basis PE B.
Proof.
move=>> HPE Hf1 Hf2; generalize HPE; intros [B [HB _]].
destruct (incomplete_basis_theorem HPE Hf1 Hf2 HB) as [m [C [Hm HC]]].
subst; eexists (concatF _ C); split; try apply concatF_ub_l; easy.
Qed.

Lemma is_free_dim_is_generator :
  forall {n} {Bf : 'E^n},
    has_dim PE n -> inclF Bf PE -> is_free Bf -> is_generator PE Bf.
Proof. intros; apply is_basis_is_generator, is_free_dim_is_basis; easy. Qed.

(* Gostiaux T1, Cor. 6.68 p. 194. *)
Lemma is_generator_ge_dim :
  forall {n ng} (Bg : 'E^ng),
    has_dim PE n -> is_generator PE Bg -> (n <= ng)%coq_nat.
Proof. move=>> [B HB] Hg; apply (is_basis_le_is_generator _ _ _ HB Hg). Qed.

Lemma lt_dim_not_is_generator :
  forall {n ng} (Bg : 'E^ng),
    has_dim PE n -> (ng < n)%coq_nat -> ~ is_generator PE Bg.
Proof.
move=>> HPE; rewrite contra_not_r_equiv Nat.nlt_ge.
apply is_generator_ge_dim; easy.
Qed.

(* Gostiaux T1, Cor. 6.68 p. 194. *)
Lemma is_generator_dim_is_basis :
  forall {n} (Bg : 'E^n), has_dim PE n -> is_generator PE Bg -> is_basis PE Bg.
Proof.
intros n Bg HPE Hg; generalize HPE; intros [B HB]; destruct n.
rewrite (hat0F_singl Bg B); easy.
move: (is_generator_nonnil _ _ Hg
    (has_dim_nonzero_sub_struct nonzero_struct_R _ HPE)).
move=> /neqF_rev [i Hi].
assert (Hf1 : inclF (singleF (Bg i)) PE).
  apply is_generator_inclF in Hg; intro; apply Hg.
assert (Hf2 : is_free (singleF (Bg i))) by now apply is_free_singleF_equiv.
destruct (incomplete_basis_theorem HPE Hf1 Hf2 Hg)
    as [m [C [Hm [HC1 HC2]]]].
apply (is_basis_monot _ (concatF (singleF (Bg i)) C)); try easy.
apply concatF_lub_invalF; try easy.
apply invalF_singleF_refl.
Qed.

(* Gostiaux T1, Cor. 6.68 p. 194. *)
Lemma is_generator_subbasis_ex :
  forall {n ng} {Bg : 'E^ng},
    has_dim PE n -> is_generator PE Bg ->
    exists (B : 'E^n), is_basis PE B /\ invalF B Bg.
Proof.
intros n ng Bg HPE Hg; generalize HPE; intros [B HB]; destruct n.
exists B; split; try easy; intros [i Hi]; easy.
move: (is_generator_nonnil _ _ Hg
    (has_dim_nonzero_sub_struct nonzero_struct_R _ HPE)).
move=> /neqF_rev [i Hi].
assert (Hf1 : inclF (singleF (Bg i)) PE).
  apply is_generator_inclF in Hg; intro; apply Hg.
assert (Hf2 : is_free (singleF (Bg i))) by now apply is_free_singleF_equiv.
destruct (incomplete_basis_theorem HPE Hf1 Hf2 Hg)
    as [m [C [Hm [HC1 HC2]]]].
exists (castF (sym_eq Hm) (concatF (singleF (Bg i)) C)); split.
apply is_basis_castF_equiv; easy.
apply invalF_castF_l_equiv, concatF_lub_invalF; try easy.
apply invalF_singleF_refl.
Qed.

Lemma is_generator_dim_is_free :
  forall {n} {Bg : 'E^n}, has_dim PE n -> is_generator PE Bg -> is_free Bg.
Proof.
intros; apply (is_basis_is_free PE), is_generator_dim_is_basis; easy.
Qed.

Lemma dim_is_free_generator_equiv :
  forall {n} {B : 'E^n},
    has_dim PE n -> inclF B PE -> is_free B <-> is_generator PE B.
Proof.
intros; split;
    [apply is_free_dim_is_generator | apply is_generator_dim_is_free]; easy.
Qed.

End Dim_R_Facts2.


Section Dim_R_Facts3.

(** More properties of has_dim on R module spaces. *)

Context {E : ModuleSpace R_Ring}.
Context {n : nat}.

Context {PE : E -> Prop}.

Hypothesis HPE : has_dim PE n.
Let PE_ms := sub_ms (has_dim_compatible_ms _ HPE).

Context {PF : PE_ms -> Prop}.
Hypothesis HPF : compatible_ms PF.

(* Gostiaux T1, Th. 6.69 pp. 194-195. *)
Lemma compatible_ms_dim_le_eq :
  exists p, has_dim PF p /\ (p <= n)%coq_nat /\ (p = n -> PF = fullset).
Proof.
destruct (nat_has_greatest_element
    (fun m => exists (C : 'PE_ms^m), inclF C PF /\ is_free C)
      0 n) as [p [Hp1 [[C [HC1 HC2]] Hp2]]].
  exists 0; split. intros [i Hi]; easy. apply is_free_nil.
  intros p Hp; apply not_ex_all_not_equiv; intros C.
  rewrite -(NNPP_equiv (is_free _)) -imp_and_equiv; intros _.
  apply (gt_dim_is_lin_dep
    (has_dim_fullset_compat _ HPE) (inclF_fullset _) Hp).
assert (HC3 : is_basis PF C).
  split; try easy; apply subset_ext_equiv; split.
  (* . *)
  intros x Hx.
  apply (is_lin_dep_insertF_rev _ _ ord0); try easy.
  specialize (Hp2 p.+1); apply (proj1 contra_equiv) in Hp2; try auto with arith.
  rewrite not_ex_all_not_equiv in Hp2; specialize (Hp2 (insertF C x ord0)).
  rewrite not_and_equiv -imp_or_equiv in Hp2; apply Hp2.
  apply insertF_monot_inclF; easy.
  (* . *)
  apply span_lb; easy.
(* *)
exists p; repeat split; try easy. apply (Dim _ _ C HC3).
intros; subst; clear Hp1.
assert (HC3' : is_basis PE (fun i => val (C i))).
  apply is_free_dim_is_basis; try easy.
  generalize HC1; apply val_inclF_compat.
  apply is_free_sub_ms_equiv; easy.
apply subset_ext_equiv; split; try easy.
intros x _;
    destruct (is_basis_ex_decomp _ _ HC3' (val x) (in_sub x)) as [L HL].
rewrite -val_comb_lin in HL; apply val_inj in HL; rewrite HL.
apply compatible_ms_comb_lin; easy.
Qed.

(* Gostiaux T1, Th. 6.69 pp. 194-195. *)
Lemma compatible_ms_dim_le : exists p, has_dim PF p /\ (p <= n)%coq_nat.
Proof. destruct compatible_ms_dim_le_eq as [p Hp]; exists p; easy. Qed.

(* Gostiaux T1, Th. 6.69 pp. 194-195. *)
Lemma compatible_ms_dim_eq :
  forall {p}, has_dim PF p -> p = n -> PF = fullset.
Proof.
destruct compatible_ms_dim_le_eq as [p1 [Hp1a [_ Hp1b]]].
intros p2 Hp2; rewrite -(dim_is_unique Hp1a Hp2); easy.
Qed.

(* Gostiaux T1, Th. 6.69 pp. 194-195.
  Supplementaire... *)

End Dim_R_Facts3.


Section Dim_R_Facts4.

(** More properties of has_dim on R module spaces. *)

Context {E : ModuleSpace R_Ring}.

Lemma has_dim_span_is_free :
  forall n (B : 'E^n), has_dim (span B) n -> is_free B.
Proof.
intros n B HB; destruct (is_generator_dim_is_basis B HB);
    try apply is_generator_span; easy.
Qed.

Lemma has_dim_span_equiv :
  forall n (B : 'E^n), has_dim (span B) n <-> is_free B.
Proof.
intros; split; [apply has_dim_span_is_free | apply is_free_has_dim_span].
Qed.

Lemma dim_correct_l : forall {PE : E -> Prop} {n}, has_dim PE n -> dim PE = n.
Proof.
intros PE n Hn; unfold dim; destruct (LPO _) as [[m Hm] | H]; simpl.
apply (dim_is_unique Hm Hn).
specialize (H n); easy.
Qed.

Lemma dim_correct_r :
  forall {PE : E -> Prop}, (forall n, ~ has_dim PE n) -> dim PE = 0.
Proof.
intros PE H; unfold dim; destruct (LPO _) as [[n Hn] | H1]; try easy; simpl.
specialize (H n); easy.
Qed.

End Dim_R_Facts4.


Section Dim_R_Facts5.

(** More properties of has_dim on R module spaces. *)

Context {E : ModuleSpace R_Ring}.

Context {PE1 PE2 : E -> Prop}.

Context {n1 n2 : nat}.

Hypothesis HPE1 : has_dim PE1 n1.
Hypothesis HPE2 : has_dim PE2 n2.

Lemma has_dim_monot : incl PE1 PE2 -> (n1 <= n2)%coq_nat.
Proof.
destruct HPE1 as [B1 [HB1a HB1b]]; apply is_generator_inclF in HB1a.
intros HPE; assert (HB1c : inclF B1 PE2)
    by apply (inclF_monot_r _ _ _ HPE HB1a).
apply (is_free_le_dim B1 HPE2); easy.
Qed.

Lemma has_dim_eq : incl PE1 PE2 -> n1 = n2 -> PE1 = PE2.
Proof.
destruct HPE1 as [B1 [HB1a HB1b]]; intros HPE Hn0; apply sym_eq; rewrite HB1a.
subst; apply is_basis_is_generator, is_free_dim_is_basis; try easy.
apply (inclF_monot_r _ _ _ HPE), is_generator_inclF; easy.
Qed.

Lemma dim_monot : incl PE1 PE2 -> (dim PE1 <= dim PE2)%coq_nat.
Proof.
rewrite (dim_correct_l HPE1) (dim_correct_l HPE2); apply has_dim_monot; easy.
Qed.

Lemma dim_eq : incl PE1 PE2 -> dim PE1 = dim PE2 -> PE1 = PE2.
Proof.
rewrite (dim_correct_l HPE1) (dim_correct_l HPE2); apply has_dim_eq; easy.
Qed.

End Dim_R_Facts5.


Section Dim_R_Facts6.

(** More properties of has_dim/dim on R module spaces. *)

Context {E : ModuleSpace R_Ring}.

Context {PE1 PE2 : E -> Prop}.

Context {n1 n2 : nat}.

Hypothesis HPE1 : has_dim PE1 n1.
Hypothesis HPE2 : has_dim PE2 n2.

Lemma has_dim_inter : exists n, has_dim (inter PE1 PE2) n.
Proof.
(*
assert (HPE0 : compatible_ms (mk_sub_ms))
destruct (compatible_ms_dim_le HPE1) as []

is_basis compatible_ms inter has_dim
sub_ms
compatible_ms_inter
*)
Admitted.

Lemma has_dim_inter_lb_l :
  forall {n}, has_dim (inter PE1 PE2) n -> (n <= n1)%coq_nat.
Proof.
Admitted.

Lemma has_dim_inter_l : has_dim (inter PE1 PE2) n1 <-> incl PE1 PE2.
Proof.
Admitted.

Lemma dim_inter : exists n, dim (inter PE1 PE2) = n.
Proof.
destruct has_dim_inter as [n Hn]; exists n; apply (dim_correct_l Hn).
Qed.

Lemma dim_inter_lb_l :
  forall {n}, dim (inter PE1 PE2) = n -> (n <= n1)%coq_nat.
Proof.
intro n; destruct has_dim_inter as [m Hm].
rewrite (dim_correct_l Hm).
intro; subst; apply has_dim_inter_lb_l; easy.
Qed.

Lemma dim_inter_l : dim (inter PE1 PE2) = dim PE1 <-> incl PE1 PE2.
Proof.
destruct has_dim_inter as [n Hn].
rewrite (dim_correct_l HPE1) (dim_correct_l Hn) -has_dim_inter_l.
split; intros Hn1; [subst; easy | apply (dim_is_unique Hn Hn1)].
Qed.

End Dim_R_Facts6.


Section Dim_R_Facts7.

(** Properties of has_dim/dim on R module spaces (from those of has_dim). *)

Context {E : ModuleSpace R_Ring}.

Variable PE1 PE2 : E -> Prop.

Context {n1 n2 : nat}.

Hypothesis HPE1 : has_dim PE1 n1.
Hypothesis HPE2 : has_dim PE2 n2.

Lemma has_dim_inter_lb_r :
  forall {n}, has_dim (inter PE1 PE2) n -> (n <= n2)%coq_nat.
Proof. intro; rewrite inter_comm; apply (has_dim_inter_lb_l HPE2 HPE1). Qed.

Lemma has_dim_inter_r : has_dim (inter PE1 PE2) n2 <-> incl PE2 PE1.
Proof. rewrite inter_comm; apply (has_dim_inter_l HPE2 HPE1). Qed.

Lemma dim_inter_lb_r :
  forall {n}, dim (inter PE1 PE2) = n -> (n <= n2)%coq_nat.
Proof.
rewrite inter_comm; move=>> Hn; apply (dim_inter_lb_l HPE2 HPE1 Hn).
Qed.

Lemma dim_inter_r : dim (inter PE1 PE2) = dim PE2 <-> incl PE2 PE1.
Proof. rewrite inter_comm; apply (dim_inter_l HPE2 HPE1). Qed.

End Dim_R_Facts7.


Section Linear_mapping_R_Facts.

Context {E F : ModuleSpace R_Ring}.

Variable f : E -> F.
Hypothesis Hf : is_linear_mapping f.

Variable PE : E -> Prop.
Variable dimPE : nat.
Hypothesis HPE : has_dim PE dimPE.
Let HPE' :=  has_dim_compatible_ms _ HPE.

Lemma rank_thm : dim (Rg_sub PE (image f PE) f) + dim (Ker_sub PE f) = dimPE.
Proof.
Admitted.

Variable PF : F -> Prop.

Hypothesis HPF : has_dim PF dimPE.
Let HPF' := has_dim_compatible_ms _ HPF.

Lemma lm_sub_is_inj_dim_equiv :
  is_inj PE PF f <-> range PE PF f /\ has_dim (Ker_sub PE f) 0.
Proof.
rewrite lm_sub_is_inj_equiv// -Ker_sub_zero_equiv// has_dim_0_equiv; easy.
Qed.

Lemma lm_sub_is_surj_dim_equiv :
  is_surj PE PF f <-> dim (Rg_sub PE PF f) = dim PF.
Proof.
rewrite lm_sub_is_surj_equiv -Rg_sub_full_equiv; split.
intros HPF1; rewrite HPF1; easy.
intros HPF1.
move: rank_thm.
(*rewrite HPF1.*)




Admitted.

Lemma lm_sub_is_bij_dim_equiv :
  is_bij PE PF f <->
  (range PE PF f /\ has_dim (Ker_sub PE f) 0) /\
  dim (Rg_sub PE PF f) = dim (image f PE).
Proof.
rewrite is_bij_equiv; try apply inhabited_ms.
rewrite lm_sub_is_inj_dim_equiv lm_sub_is_surj_dim_equiv; try easy.
Admitted.

Lemma is_inj_is_surj_equiv : is_inj PE PF f <-> is_surj PE PF f.
Proof.
rewrite lm_sub_is_inj_dim_equiv lm_sub_is_surj_dim_equiv.
move: rank_thm => H0; split; [intros [H1 H2] | intros H1].
(* *)





(*
split.
(* *)
move=> /(lm_sub_is_inj_rev Hf HPE') [HPE1 HPE2].
apply lm_sub_is_surj. admit. (* WRONG! *)
(* *)
move=> /lm_sub_is_surj_rev HPE1.
apply lm_sub_is_inj; try easy.
*)



Admitted.

Lemma is_bij_is_inj_equiv : is_bij PE PF f <-> is_inj PE PF f.
Proof.
rewrite is_bij_equiv; try apply inhabited_ms; split; try easy.
rewrite is_inj_is_surj_equiv; easy.
Qed.

Lemma is_bij_is_surj_equiv : is_bij PE PF f <-> is_surj PE PF f.
Proof. rewrite -> is_bij_is_inj_equiv, is_inj_is_surj_equiv; easy. Qed.

End Linear_mapping_R_Facts.


Section Dual_family.

Context {E : ModuleSpace R_Ring}.
Context {n : nat}.

Definition is_dual_family :=
  fun (e : 'E^n) (e' : '(E -> R)^n) =>
    forall i j, e' i (e j) = kronecker i j.

(*
Lemma dual_basis_is_dual_family :
  forall B (HB : is_basis PE B), is_dual_family B (dual_basis B HB).
Proof.
intros B HB i j; apply dual_basis_kronecker.
Qed.*)

Lemma is_dual_is_free : forall e e',
  is_dual_family e e' -> is_free e -> is_free e'.
Proof.
intros e e' H H1 L HL; apply eqF; intros j.
rewrite <- comb_lin_kronecker_in_r, comb_lin_comm_R.
apply trans_eq with ((comb_lin L e') (e j)); try now rewrite HL.
rewrite comb_lin_fun_compat.
apply comb_lin_ext_r; intros; rewrite H; apply kronecker_sym.
Qed.

Lemma is_dual_is_free_rev : forall e e',
  (forall i, is_linear_mapping (e' i)) ->
  is_dual_family e e' -> is_free e' -> is_free e.
Proof.
intros e e' H0 H H1 L HL; apply eqF; intros j.
rewrite <- comb_lin_kronecker_in_r, comb_lin_comm_R.
apply trans_eq with (comb_lin L (fun i => e' j (e i))).
apply comb_lin_ext_r; intros; rewrite H; easy.
rewrite -linear_mapping_comb_lin_compat; try easy.
rewrite HL is_linear_mapping_zero; easy.
Qed.

Lemma is_dual_is_basis : forall e e',
   (forall i, is_linear_mapping (e' i)) ->
  is_dual_family e e' -> is_basis (span e) e <-> is_basis (span e') e'.
Proof.
intros e e' H1 H2; split; intros (H3,H4); split; try easy.
apply is_dual_is_free with e; easy.
apply is_dual_is_free_rev with e'; easy.
Qed.

End Dual_family.


Section Dual_basis.

Context {E : ModuleSpace R_Ring}.

Context {n : nat}.

Context {PE : E -> Prop}.

Variable B : 'E^n.
Hypothesis HB : is_basis PE B.

Definition dual_basis : '(E -> R)^n := fun i x =>
  match (excluded_middle_informative (PE x)) with
  | left Hx (* in PE *) =>
      let (L, _) :=
        span_EX _ _ (eq_ind_r (@^~ x) Hx (sym_eq (proj1 HB))) in
      L i
  | right _ (* not in PE *) => 0
  end.

(*
Definition dual_basis : '(E -> R)^n := fun i x =>
   match (excluded_middle_informative (PE x)) with
     | left Hx => let (L,_) :=
             (span_EX _ _ (proj1 (proj1 HB x) Hx)) in
                 L i
     | right _ => 0 (* not in PE *)
   end.
*)
(*
Proof.
intros i x.
destruct HB as [HB1 HB2].
destruct (excluded_middle_informative (PE x)) as [Hx | Hx].
2: apply 0. (*not in PE *)
specialize (proj1 (HB1 x) Hx); intros H1.
destruct (span_EX _ _ H1) as [L HL].
apply (L i).
Defined.*)

(* ceci n'est pas la bonne dÃ©f car ce n'est pas un linear mapping
  devrait Ãªtre :
  x = z_PE (\in PE) + y 
    (avec y \not \in PE, y dans l'"orthogonal"/conjuguÃ© de PE)
    de faÃ§on unique ; donc on renvoie le L_k de z_PE.
*)

Lemma dual_basis_correct : forall x L,
  x = comb_lin L B -> forall k, (dual_basis k) x = L k.
Proof.
intros x L H k.
unfold dual_basis.
destruct (excluded_middle_informative _) as [Hx | Hx].
destruct (span_EX _ _ _) as [L' HL'].
assert (T:L=L'); [idtac| rewrite T; easy].
apply (is_free_uniq_decomp B); try easy.
apply HB.
rewrite <- H; easy.
contradict Hx.
rewrite (proj1 HB).
rewrite H; easy.
Qed.

Lemma dual_basis_out : forall x, ~ PE x ->
  forall k , (dual_basis k) x = 0.
Proof.
intros x H k.
unfold dual_basis.
destruct (excluded_middle_informative _) as [Hx | Hx]; easy.
Qed.

Lemma dual_basis_is_linear_mapping :
  forall i, 
    (forall x y, PE x -> PE y -> 
       dual_basis i (x + y) = dual_basis i x + dual_basis i y) 
    /\ (forall x l, dual_basis i (scal l x) = scal l (dual_basis i x)).
  (* nearly is_linear_mapping (dual_basis i) *)
Proof.
intros i.
split.
intros x y Hx Hy.
generalize (eq_ind_r (@^~ x) Hx (sym_eq (proj1 HB)));
    intros Y; inversion Y as [Lx HLx]; clear Y.
generalize (eq_ind_r (@^~ y) Hy (sym_eq (proj1 HB)));
    intros Y; inversion Y as [Ly HLy]; clear Y.
erewrite dual_basis_correct.
2: rewrite -comb_lin_plus_l; easy.
erewrite dual_basis_correct; try easy.
erewrite dual_basis_correct; try easy.
(* *)
intros x l.
case (classic (PE x)); intros Hx.
generalize (eq_ind_r (@^~ x) Hx (sym_eq (proj1 HB)));
    intros Y; inversion Y as [L HL].
rewrite -> dual_basis_correct with (scal l (comb_lin L B)) (scal l L) i.
rewrite -> dual_basis_correct with (comb_lin L B) L i; try easy.
rewrite comb_lin_scal_l; easy.
rewrite (dual_basis_out x); try assumption.
replace 0 with (@zero R_ModuleSpace) by easy.
rewrite scal_zero_r.
case (Req_dec l 0); intros Hl.
rewrite Hl; replace 0 with (@zero R_Ring) by easy.
rewrite scal_zero_l.
eapply trans_eq.
apply dual_basis_correct.
apply sym_eq, comb_lin_zero_compat_l; try easy.
easy.
apply dual_basis_out.
intros T.
apply Hx.
rewrite (proj1 HB).
replace x with (scal (/l) (scal l x)).
apply span_compatible_ms; rewrite <- (proj1 HB); easy.
rewrite -> scal_assoc, Rinv_l; try assumption.
replace 1 with (@one R_Ring) by easy.
apply scal_one.
Qed.

(* autre possibilitÃ© de dÃ©finition de dual_basis 
   facile Ã  utiliser ????? *)
(*Definition dual_basis2 : '(@Sg E PE -> R)^n := fun i x =>
   let (L,_) :=
      (span_EX _ _ (eq_ind_r (@^~ (val x)) (val_in_P x) (sym_eq (proj1 HB)))) in
         L i.*)

Lemma HPE: compatible_ms PE.
Proof.
apply has_dim_compatible_ms with n.
exists B; easy.
Qed.

Definition dual_basis2 : '(sub_ms HPE -> R)^n := fun i x =>
   let (L,_) :=
      (span_EX _ _ (eq_ind_r (@^~ (val x)) (in_sub x) (sym_eq (proj1 HB)))) in
         L i.

Lemma dual_basis2_correct : forall x L,
  val x = comb_lin L B -> forall k, (dual_basis2 k) x = L k.
Proof.
intros x L H k; unfold dual_basis2.
destruct (span_EX B (val x)) as (L',HL').
replace L with L'; try easy.
apply is_free_uniq_decomp with B.
apply HB.
rewrite <- H; easy.
Qed.

Lemma dual_basis2_is_linear_mapping :
  forall i,
      is_linear_mapping (dual_basis2 i).
Proof.
intros i; split.
intros x y.
destruct (span_EX B (val (x))) as (Lx,HLx).
rewrite <- (proj1 HB); apply x.
destruct (span_EX B (val (y))) as (Ly,HLy).
rewrite <- (proj1 HB); apply y.
rewrite -> dual_basis2_correct with (1:=HLx).
rewrite -> dual_basis2_correct with (1:=HLy).
rewrite -> dual_basis2_correct with (L:=Lx + Ly); try easy.
rewrite comb_lin_plus_l.
rewrite <- HLx, <- HLy; easy.
(* *)
intros x l.
destruct (span_EX B (val (x))) as (Lx,HLx).
rewrite <- (proj1 HB); apply x.
rewrite -> dual_basis2_correct with (1:=HLx).
rewrite -> dual_basis2_correct with (L:=scal l Lx); try easy.
rewrite comb_lin_scal_l -HLx; easy.
Qed.

Lemma B_in_PE : forall i, PE (B i).
Proof.
apply is_generator_inclF, HB.
Qed.

Lemma dual_basis2_kronecker : forall i j, 
   dual_basis2 i (mk_sub_ms _ (B j) (B_in_PE j)) = kronecker i j.
Proof.
intros i j.
rewrite -> dual_basis2_correct with (L := (fun i0 => kronecker i0 j)); try easy.
symmetry; simpl.
apply comb_lin_kronecker_in_l.
Qed.


Lemma dual_basis_is_basis2 : 
    is_basis (span dual_basis2) dual_basis2.
Proof.
pose (BB := fun i => mk_sub_ms HPE (B i) (B_in_PE i)).
apply (is_dual_is_basis BB dual_basis2).
intros i; apply dual_basis2_is_linear_mapping.
intros i j.
apply dual_basis2_kronecker.
split; try easy.
intros L HL.
apply HB.
apply trans_eq with (val (comb_lin L BB)).
2: rewrite HL; easy.
rewrite val_comb_lin.
apply comb_lin_eq_l; easy.
Qed.

(* SB fin essai ; probablement Ã  voir oÃ¹ c'est utilisÃ© avant 
   d'avancer les preuves... *)

Lemma dual_basis_kronecker : forall i j, dual_basis i (B j) = kronecker i j.
Proof.
intros i j.
rewrite -> dual_basis_correct with (L := (fun i0 => kronecker i0 j)); try easy.
symmetry.
apply comb_lin_kronecker_in_l.
Qed.

(* FC (18/10/2023): this lemma is not yet used!
(* faux *)
Lemma dual_basis_is_basis : is_basis (span dual_basis) dual_basis.
Proof.
apply (is_dual_is_basis B dual_basis).
2: intros i j; apply dual_basis_kronecker.

aglop. (* faux car pas hors de PE *)

split; try easy.
apply HB.
Aglopted.
*)

Lemma dual_basis_span_out :
  forall f x, span dual_basis f -> ~ PE x -> f x = 0.
Proof.
intros f x H1 H2.
inversion H1 as [L HL].
replace 0 with (@zero R_ModuleSpace) by easy.
rewrite comb_lin_fun_compat.
apply comb_lin_zero_compat_r, eqF; intros i.
apply dual_basis_out; easy.
Qed.

End Dual_basis.


Close Scope R_scope.
Local Open Scope AffineSpace_scope.


Section AffineSpace_FD_Def.

Context {K : Ring}.
Context {V : ModuleSpace K}.
Context {E : AffineSpace V}.

(* TODO FC (07/06/2023): try to use new span_struct. *)

Inductive aff_span {n} (A : 'E^n) : E -> Prop :=
  Aff_span : forall L, invertible (sum L) -> aff_span A (barycenter L A).

Lemma aff_span_EX :
  forall {n} (A : 'E^n) G,
    aff_span A G -> { L | sum L = 1 /\ G = barycenter L A }.
Proof.
move=>> Hx; apply constructive_indefinite_description.
induction Hx as [L HL]; eexists; apply (barycenter_normalized _ _ _ HL); easy.
Qed.

Lemma aff_span_ex :
  forall {n} (A : 'E^n) G,
    (exists L, invertible (sum L) /\ G = barycenter L A) -> aff_span A G.
Proof. move=>> [L [HL1 HL2]]; rewrite HL2; easy. Qed.

Lemma aff_span_ext :
  forall {n} (A1 A2 : 'E^n), A1 = A2 -> aff_span A1 = aff_span A2.
Proof. intro; apply f_equal. Qed.

Definition in_aff_point (A0 : E) := aff_span (singleF A0).
Definition in_aff_line (A0 A1 : E) := aff_span (coupleF A0 A1).
Definition in_aff_plane (A0 A1 A2 : E) := aff_span (tripleF A0 A1 A2).
(*Definition in_aff_3d_space (A0 A1 A2 A3 : E) := aff_span (quadrupleF A0 A1 A2 A3).*)

Definition barycenter_surjL (PE : E -> Prop) {n} (A : 'E^n) :=
  forall G, PE G -> exists L, invertible (sum L) /\ G = barycenter L A.
Definition barycenter_injL {n} (A : 'E^n) :=
  forall L L', invertible (sum L) -> sum L = sum L' ->
    barycenter L A = barycenter L' A -> L = L'.
Definition barycenter_bijL (PE : E -> Prop) {n} (A : 'E^n) :=
  forall G, PE G -> exists! L, sum L = 1 /\ G = barycenter L A.

Definition is_aff_gen (PE : E -> Prop) {n} (A : 'E^n) := PE = aff_span A.

Lemma is_aff_gen_ext :
  forall (PE : E -> Prop) {n} (A1 A2 : 'E^n),
    A1 = A2 -> is_aff_gen PE A1 -> is_aff_gen PE A2.
Proof. intros; subst; easy. Qed.

Definition is_aff_indep {n} (A : 'E^n.+1) :=
  forall i0, is_free (frameF A i0).

Lemma is_aff_indep_ext :
  forall {n} (A1 A2 : 'E^n.+1), A1 = A2 -> is_aff_indep A1 -> is_aff_indep A2.
Proof. intros; subst; easy. Qed.

(* FC: this could be a notation... *)
Definition is_aff_dep {n} (A : 'E^n.+1) := ~ is_aff_indep A.

Lemma is_aff_dep_ext :
  forall {n} (A1 A2 : 'E^n.+1), A1 = A2 -> is_aff_dep A1 -> is_aff_dep A2.
Proof. intros; subst; easy. Qed.

Definition is_aff_basis (PE : E -> Prop) {n} (A : 'E^n.+1) :=
  is_aff_gen PE A /\ is_aff_indep A.

Lemma is_aff_basis_ext :
  forall (PE : E -> Prop) {n} (A1 A2 : 'E^n.+1),
    A1 = A2 -> is_aff_basis PE A1 -> is_aff_basis PE A2.
Proof. intros; subst; easy. Qed.

Inductive has_aff_dim (PE : E -> Prop) n : Prop :=
  Aff_dim : forall (A : 'E^n.+1), is_aff_basis PE A -> has_aff_dim PE n.

Lemma has_aff_dim_EX :
  forall (PE : E -> Prop) n, has_aff_dim PE n -> { A : 'E^n.+1 | is_aff_basis PE A }.
Proof.
move=>> H; apply constructive_indefinite_description.
induction H as [A]; exists A; easy.
Qed.

Lemma has_aff_dim_ex:
  forall (PE : E -> Prop) n,
    (exists A : 'E^n.+1, is_aff_basis PE A) -> has_aff_dim PE n.
Proof. move=>> [A HA]. apply (Aff_dim _ _ A HA). Qed.

Lemma has_aff_dim_ext :
  forall (PE1 PE2 : E -> Prop) n1 n2,
    PE1 = PE2 -> n1 = n2 -> has_aff_dim PE1 n1 -> has_aff_dim PE2 n2.
Proof. intros; subst; easy. Qed.

Definition aff_dim (PE : E -> Prop) :=
  match (LPO (has_aff_dim PE) (fun=> classic _)) with
  | inleft H => proj1_sig H
  | inright _ => O
  end.

Lemma aff_dim_ext :
  forall (PE1 PE2 : E -> Prop), PE1 = PE2 -> aff_dim PE1 = aff_dim PE2.
Proof. intros; subst; easy. Qed.

End AffineSpace_FD_Def.


Section Aff_span_Subset_Facts.

Context {K : Ring}.
Context {V : ModuleSpace K}.
Context {E : AffineSpace V}.

Lemma aff_span_eq :
  forall {n} (A : 'E^n), aff_span A = barycenter_closure (inF^~ A).
Proof.
intros n A; apply subset_ext_equiv; split; intros C HC.
induction HC; apply Barycenter_closure; [easy | apply invalF_refl].
induction HC as [m L C HL HC].
destruct (barycenter_injF_ex L C HL) as [p [N [D [HN [HD1 [HD2 ->]]]]]].
clear L HL; apply ((invalF_trans _ D _)^~ HC) in HD2.
destruct (barycenter_extendF N D A) as [L [HL1 [HL2 ->]]]; easy.
Qed.

Lemma aff_span_inclF_diag : forall {n} (A : 'E^n), inclF A (aff_span A).
Proof.
intros n A i; rewrite -barycenter_kron_r; apply Aff_span.
rewrite sum_kron_r; apply invertible_one.
Qed.

Lemma aff_span_ub : forall {n} (A : 'E^n) C i, C = A i -> aff_span A C.
Proof. intros; subst; apply aff_span_inclF_diag. Qed.

Lemma aff_span_inclF :
  forall {n1 n2} (A1 : 'E^n1) (A2 : 'E^n2), invalF A1 A2 -> inclF A1 (aff_span A2).
Proof.
move=>> HA i; destruct (HA i) as [i2 Hi2]; rewrite Hi2; apply aff_span_inclF_diag.
Qed.

Lemma aff_spanF_ex :
  forall {n1 n2} (A1 : 'E^n1) (A2 : 'E^n2),
    inclF A1 (aff_span A2) <->
    exists M12, forall i1,
      invertible (sum (M12 i1)) /\ A1 i1 = barycenter (M12 i1) A2.
Proof.
intros n1 n2 A1 A2; split; intros HA.
(* *)
assert (HA' : forall i1, exists L2,
    invertible (sum L2) /\ A1 i1 = barycenter L2 A2).
  intros i1; destruct (HA i1) as [L2]; exists L2; easy.
apply (choice _ HA').
(* *)
intros i1; destruct HA as [M HM], (HM i1) as [HM1a HM1b]; rewrite HM1b; easy.
Qed.

Lemma aff_spanF_ex1 :
  forall {n1 n2} (A1 : 'E^n1) (A2 : 'E^n2),
    inclF A1 (aff_span A2) <->
    exists M12, forall i1, sum (M12 i1) = 1 /\ A1 i1 = barycenter (M12 i1) A2.
Proof.
move=>>; rewrite aff_spanF_ex; split; move=> [M12 /all_and_equiv [HM12 HA1]].
(* *)
exists (fun i1 => scal (/ sum (M12 i1)) (M12 i1)); intros i1.
apply barycenter_normalized; easy.
(* *)
exists M12; intros; rewrite HM12; split; [apply invertible_one | easy].
Qed.

Lemma aff_span_incl :
  forall {n1 n2} (A1 : 'E^n1) (A2 : 'E^n2),
    inclF A1 (aff_span A2) -> incl (aff_span A1) (aff_span A2).
Proof.
move=>> HA1 _ [L1 HL1]; apply aff_spanF_ex1 in HA1; destruct HA1 as [M HM].
apply all_and_equiv in HM; destruct HM as [HM HA1].
apply aff_span_ex; exists (fun i2 => comb_lin L1 (M^~ i2)); split.
2: apply barycenter2_r; easy.
replace (sum _) with (sum L1); try easy.
rewrite -comb_lin_sum_r -(comb_lin_ext_r _ ones).
rewrite comb_lin_ones_r; easy.
intros i1; rewrite (HM i1); easy.
Qed.

Lemma aff_span_monot :
  forall {n1 n2} (A1 : 'E^n1) (A2 : 'E^n2),
    invalF A1 A2 -> incl (aff_span A1) (aff_span A2).
Proof. intros; apply aff_span_incl, aff_span_inclF; easy. Qed.

Lemma aff_span_inv_frameF_orig :
  forall {n} (B : 'V^n) (O : E) i0, aff_span (inv_frameF O B i0) O.
Proof.
intros n B O i0; rewrite -{2}(transl_zero O); apply (aff_span_ub _ _ i0).
unfold inv_frameF; rewrite translF_insertF insertF_correct_l; easy.
Qed.

Lemma is_aff_basis_is_aff_gen :
  forall (PE : E -> Prop) {n} (A : 'E^n.+1),
    is_aff_basis PE A -> is_aff_gen PE A.
Proof. move=>> [HA _]; easy. Qed.

Lemma is_aff_basis_is_aff_indep :
  forall (PE : E -> Prop) {n} (A : 'E^n.+1),
    is_aff_basis PE A -> is_aff_indep A.
Proof. move=>> [_ HA]; easy. Qed.

Lemma is_aff_gen_nonempty :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1}, is_aff_gen PE A -> exists O, PE O.
Proof. move=> PE n A ->; exists (A ord0); apply aff_span_inclF_diag. Qed.

Lemma is_aff_basis_nonempty :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1},
    is_aff_basis PE A -> exists O, PE O.
Proof. move=>> [HA _]; apply (is_aff_gen_nonempty HA). Qed.

Lemma has_aff_dim_is_nonempty :
  forall {PE : E -> Prop} {n}, has_aff_dim PE n -> exists O, PE O.
Proof. move=>> [A HA]; apply (is_aff_basis_nonempty HA). Qed.

End Aff_span_Subset_Facts.


Section Aff_span_Affine_Facts.

Context {K : Ring}.
Context {V : ModuleSpace K}.
Context {E : AffineSpace V}.

Lemma aff_span_exs :
  forall {n1 n2} {A2 : 'E^n2} {G1 : 'E^n1},
    inclF G1 (aff_span A2) ->
    exists L, (forall i, sum (L i) = 1) /\ G1 = fun i => barycenter (L i) A2.
Proof.
move=> n1 n2 A2 G1 HG1.
destruct (choice (fun i L => sum L = 1 /\ G1 i = barycenter L A2)) as [L HL].
  intros i; destruct (aff_span_EX _ _ (HG1 i)) as [L HL]; exists L; easy.
apply all_and_equiv in HL; exists L; split; try apply eqF; easy.
Qed.

Lemma is_aff_indep_alt :
  forall {n} {A : 'E^n.+1} i0, is_free (frameF A i0) -> is_aff_indep A.
Proof.
intros n A i0 HA i; destruct (ord_eq_dec i i0) as [Hi | Hi]; try now rewrite Hi.
destruct n as [|n]. contradict Hi; rewrite !ord1; easy.
intros L; unfold frameF; rewrite (vectF_change_orig (A i0))
    comb_lin_plus_r -scal_sum_l scal_opp -vect_sym vectF_skipF.
rewrite -comb_lin_insertF_l (comb_lin_skip_zero_r _ _ i0 (vectF_zero_alt _ _)).
move=> /HA /eqF_rev HL1.
assert (HL1a : skipF L (insert_ord (not_eq_sym Hi)) = 0).
  apply skipF_zero_compat; move=> j /skip_insert_ord_neq Hj.
  specialize (HL1 (insert_ord Hj)).
  rewrite skipF_correct insertF_correct in HL1; easy.
apply (eqF_zero_skipF _ (insert_ord (not_eq_sym Hi))); try easy.
rewrite -sum_one // opp_zero_equiv; move: (HL1 (insert_ord Hi)).
rewrite zeroF skipF_correct insertF_correct_l; easy.
Qed.

Lemma is_aff_dep_alt :
  forall {n} {A : 'E^n.+1} i0, is_lin_dep (frameF A i0) -> is_aff_dep A.
Proof. move=>>; rewrite -contra_equiv; easy. Qed.

End Aff_span_Affine_Facts.


Section AffineSpace_FD_R_Facts.

Context {V : ModuleSpace R_Ring}.
Context {E : AffineSpace V}.

(* aff_span A is an affine subspace. *)
Lemma aff_span_compatible_as :
  forall {n} (A : 'E^n), compatible_as (aff_span A).
Proof.
intros; apply compatible_as_equiv, sym_eq; rewrite aff_span_eq.
apply barycenter_closure_idem_R.
Qed.

Lemma aff_span_lin_eq :
  forall {n} {A : 'E^n.+1} {O} i0,
    aff_span A O -> vectP (aff_span A) O = span (frameF A i0).
Proof.
intros n A O i0 HO; rewrite (vectP_orig_indep (A i0) HO).
2: { apply compatible_as_ms_equiv_R; try apply aff_span_inclF_diag.
    move=>> HL HC; apply aff_span_compatible_as; easy. }
apply subset_ext_equiv; split; unfold vectP, preimage; intros u Hu.
(* *)
apply aff_span_EX in Hu; destruct Hu as [L [HL1 HL2]].
rewrite (barycenter_correct_orig_equiv (A i0)) in HL2.
2: rewrite HL1; apply invertible_one.
rewrite transl_correct_r HL1 scal_one in HL2; rewrite HL2.
unfold frameF; rewrite vectF_skipF (comb_lin_skipF _ _ i0)
    vectF_correct vect_zero scal_zero_r plus_zero_l; easy.
(* *)
induction Hu as [L]; unfold frameF; rewrite vectF_skipF (transl_comb_lin i0).
rewrite translF_skipF translF_vectF insertF_skipF.
apply Aff_span, invertible_eq_one, sum_insertF_baryc.
Qed.

Lemma is_aff_gen_lin :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1} {O} i0,
    PE O -> is_aff_gen PE A -> is_generator (vectP PE O) (frameF A i0).
Proof.
intros PE n A O i0 HO HA.
rewrite HA (aff_span_lin_eq i0); [apply is_generator_span | rewrite -HA//].
Qed.

Lemma is_aff_gen_lin_rev :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1} O i0,
    aff_span A O -> is_generator (vectP PE O) (frameF A i0) -> is_aff_gen PE A.
Proof.
intros PE n A O i0 HO HA.
apply (vectP_inj _ _ O); rewrite (aff_span_lin_eq i0); easy.
Qed.

Lemma is_aff_gen_lin_equiv :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1} O i0,
    PE O /\ is_aff_gen PE A <->
    aff_span A O /\ is_generator (vectP PE O) (frameF A i0).
Proof.
move=>>; split; intros [HO HA]; split.
(* *)
rewrite -HA; easy.
apply is_aff_gen_lin; easy.
(* *)
rewrite -vectP_zero_closed_equiv HA; apply span_zero_closed.
apply (is_aff_gen_lin_rev _ _ HO HA).
Qed.

Lemma is_lin_gen_aff :
  forall {PV : V -> Prop} {n} {B : 'V^n} (O : E) i0,
    is_generator PV B -> is_aff_gen (translP PV O) (inv_frameF O B i0).
Proof.
intros PV n B O i0 HB.
apply (is_aff_gen_lin_rev O i0); try rewrite vectP_translP frameF_inv_frameF//.
apply aff_span_inv_frameF_orig.
Qed.

Lemma is_lin_gen_aff_rev :
  forall {PV : V -> Prop} {n} {B : 'V^n} (O : E) i0,
    zero_closed PV ->
    is_aff_gen (translP PV O) (inv_frameF O B i0) -> is_generator PV B.
Proof.
move=> PV n B O i0 /(translP_zero_closed_equiv PV O) HO /(is_aff_gen_lin i0 HO).
rewrite vectP_translP frameF_inv_frameF; easy.
Qed.

Lemma is_lin_gen_aff_equiv :
  forall {PV : V -> Prop} {n} {B : 'V^n} (O : E) i0,
    is_generator PV B <->
    zero_closed PV /\ is_aff_gen (translP PV O) (inv_frameF O B i0).
Proof.
intros PV n B O i0; split.
(* *)
intros HB; split.
apply (is_generator_zero_closed _ _ HB).
apply is_lin_gen_aff; easy.
(* *)
intros [HPV HB]; apply (is_lin_gen_aff_rev _ _ HPV HB).
Qed.

Lemma is_aff_basis_lin :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1} {O} i0,
    PE O -> is_aff_basis PE A -> is_basis (vectP PE O) (frameF A i0).
Proof. move=>> HO [HA1 HA2]; split; try easy; apply is_aff_gen_lin; easy. Qed.

Lemma is_aff_basis_lin_rev :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1} O i0,
    aff_span A O -> is_basis (vectP PE O) (frameF A i0) -> is_aff_basis PE A.
Proof.
intros PE n A O i0 HO [HA1 HA2]; split.
apply (is_aff_gen_lin_rev _ _ HO HA1).
apply (is_aff_indep_alt i0); easy.
Qed.

Lemma is_aff_basis_lin_equiv :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1} {O} i0,
    PE O /\ is_aff_basis PE A <->
    aff_span A O /\ is_basis (vectP PE O) (frameF A i0).
Proof.
intros PE n A O i0; unfold is_aff_basis, is_basis.
rewrite -and_assoc (is_aff_gen_lin_equiv _ i0) and_assoc.
split; intros [HA1 [HA2 HA3]]; repeat split; try easy.
apply (is_aff_indep_alt i0); easy.
Qed.

Lemma is_basis_aff :
  forall {PV : V -> Prop} {n} {B : 'V^n} (O : E) i0,
    is_basis PV B -> is_aff_basis (translP PV O) (inv_frameF O B i0).
Proof.
intros PV n B O i0 HB.
apply (is_aff_basis_lin_rev _ i0 (aff_span_inv_frameF_orig _ _ _)).
rewrite vectP_translP frameF_inv_frameF; easy.
Qed.

Lemma is_basis_aff_rev :
  forall {PV : V -> Prop} {n} {B : 'V^n} (O : E) i0,
    zero_closed PV ->
    is_aff_basis (translP PV O) (inv_frameF O B i0) -> is_basis PV B.
Proof.
move=> PV n B O i0 /(translP_zero_closed_equiv _ O) HO /(is_aff_basis_lin i0 HO).
rewrite vectP_translP frameF_inv_frameF; easy.
Qed.

Lemma is_basis_aff_equiv :
  forall {PV : V -> Prop} {n} {B : 'V^n} (O : E) i0,
    is_basis PV B <->
    zero_closed PV /\ is_aff_basis (translP PV O) (inv_frameF O B i0).
Proof.
intros; split.
(* *)
intros HB; split.
apply compatible_ms_zero, (is_basis_compatible_ms _ _ HB).
apply (is_basis_aff _ _ HB).
(* *)
intros [HPV HB]; apply (is_basis_aff_rev _ _ HPV HB).
Qed.

Lemma has_aff_dim_lin :
  forall {PE : E -> Prop} {n} {O},
    PE O -> has_aff_dim PE n -> has_dim (vectP PE O) n.
Proof.
move=>> HO [A /(is_aff_basis_lin ord0 HO) HA]; apply (Dim _ _ _ HA).
Qed.

Lemma has_aff_dim_lin_rev :
  forall {PE : E -> Prop} {n} O, has_dim (vectP PE O) n -> has_aff_dim PE n.
Proof.
move=> PE n O [B /(is_basis_aff O ord0) HB];
    rewrite translP_vectP in HB; apply (Aff_dim _ _ _ HB).
Qed.

Lemma has_aff_dim_lin_equiv :
  forall {PE : E -> Prop} {n} {O},
    PE O /\ has_aff_dim PE n <-> has_dim (vectP PE O) n.
Proof.
intros; split; [intros [HO HPE] | intros HPE; split].
apply (has_aff_dim_lin HO HPE).
apply vectP_zero_closed_equiv, (has_dim_zero_closed _ HPE).
apply (has_aff_dim_lin_rev _ HPE).
Qed.

Lemma has_dim_aff :
  forall {PV : V -> Prop} {n} (O : E),
    has_dim PV n -> has_aff_dim (translP PV O) n.
Proof.
move=> PV n O [B /(is_basis_aff O ord0) HB]; apply (Aff_dim _ _ _ HB).
Qed.

Lemma has_dim_aff_rev :
  forall {PV : V -> Prop} {n} (O : E),
    zero_closed PV -> has_aff_dim (translP PV O) n -> has_dim PV n.
Proof.
move=> PV n O /(translP_zero_closed_equiv _ O) HO
    [A /(is_aff_basis_lin ord0 HO) HA];
    rewrite vectP_translP in HA; apply (Dim _ _ _ HA).
Qed.

Lemma has_dim_aff_equiv :
  forall {PV : V -> Prop} {n} (O : E),
    has_dim PV n <-> zero_closed PV /\ has_aff_dim (translP PV O) n.
Proof.
intros; split; [intros HPV; split | intros [HO HPV]].
apply (has_dim_zero_closed _ HPV).
apply (has_dim_aff _ HPV).
apply (has_dim_aff_rev _ HO HPV).
Qed.

Lemma is_aff_indep_monot :
  forall {n1 n2} {A1 : 'E^n1.+1} {A2 : 'E^n2.+1},
    injective A1 -> invalF A1 A2 -> is_aff_indep A2 -> is_aff_indep A1.
Proof.
intros n1 n2 A1 A2 HA1 HA HA2; destruct (HA ord0) as [i2 Hi2].
apply (is_aff_indep_alt ord0), (is_free_monot _ (frameF A2 i2)); try easy.
apply frameF_inj_equiv, skipF_inj; easy.
apply frameF_invalF_equiv; [| apply skipF_invalF]; easy.
Qed.

Lemma is_aff_dep_monot :
  forall {n1 n2} {A1 : 'E^n1.+1} {A2 : 'E^n2.+1},
    injective A1 -> invalF A1 A2 -> is_aff_dep A1 -> is_aff_dep A2.
Proof.
move=>> HA1 HA; rewrite -contra_equiv; apply is_aff_indep_monot; easy.
Qed.

Lemma is_aff_indep_skipF :
  forall {n} {A : 'E^n.+2} i0, is_aff_indep A -> is_aff_indep (skipF A i0).
Proof.
intros n A i0 HA; destruct (ord_eq_dec i0 ord0) as [Hi0 | Hi0].
(* *)
assert (Hi0' : i0 <> ord_max) by (rewrite Hi0; apply ord_0_not_max).
specialize (HA ord_max); apply (skipF_is_free_compat (insert_ord Hi0')) in HA.
apply (is_aff_indep_alt ord_max); move: HA; apply is_free_ext; unfold frameF.
rewrite <- vectF_skipF, skipF_correct_r, liftF_S_max; try now rewrite Hi0.
rewrite -skip2F_correct (skip2F_equiv_def _ (not_eq_sym Hi0')) insert_ord_max//.
(* *)
specialize (HA ord0); apply (skipF_is_free_compat (insert_ord Hi0)) in HA.
apply (is_aff_indep_alt ord0); move: HA; apply is_free_ext; unfold frameF.
rewrite -vectF_skipF (skipF_correct_alt (not_eq_sym Hi0));
    try now apply skip_ord_0.
rewrite -skip2F_correct (skip2F_equiv_def _ (not_eq_sym Hi0)) insert_ord_0 //.
Qed.

Lemma aff_dim_lin_eq :
  forall {PE : E -> Prop} {O}, PE O -> aff_dim PE = dim (vectP PE O).
Proof.
intros PE O HO; unfold aff_dim; destruct (LPO _ _) as [[n Hn] | H]; simpl.
apply sym_eq, dim_correct_l, has_aff_dim_lin; easy.
apply sym_eq, dim_correct_r; intros n Hn; specialize (H n).
contradict H; apply has_aff_dim_lin_rev in Hn; easy.
Qed.

Lemma is_aff_gen_dim_is_aff_basis :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1},
    has_aff_dim PE n -> is_aff_gen PE A -> is_aff_basis PE A.
Proof.
intros PE n A HPE HA; destruct (has_aff_dim_is_nonempty HPE) as [O HO].
assert (HO' : aff_span A O) by now rewrite -HA.
move: (has_aff_dim_lin HO HPE) => HPE'.
move: (is_aff_gen_lin ord0 HO HA) => HA'.
apply (is_aff_basis_lin_rev _ ord0 HO').
apply (is_generator_dim_is_basis _ HPE' HA').
Qed.

Lemma is_aff_gen_dim_is_aff_indep :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1},
    has_aff_dim PE n -> is_aff_gen PE A -> is_aff_indep A.
Proof.
intros PE n A HPE HA; apply (is_aff_basis_is_aff_indep PE).
apply is_aff_gen_dim_is_aff_basis; easy.
Qed.

Lemma is_aff_indep_dim_is_aff_gen :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1},
    has_aff_dim PE n -> inclF A PE -> is_aff_indep A -> is_aff_gen PE A.
Proof.
intros PE n A HPE HA1 HA2.
move: (has_aff_dim_lin (HA1 ord0) HPE) => HPE'.
apply (@is_aff_gen_lin_rev _ _ _ (A ord0) ord0).
apply aff_span_inclF_diag.
apply (is_free_dim_is_generator HPE'); try easy.
apply frameF_inclF; easy.
Qed.

Lemma is_aff_indep_dim_is_aff_basis :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1},
    has_aff_dim PE n -> inclF A PE -> is_aff_indep A -> is_aff_basis PE A.
Proof. intros; split; [apply is_aff_indep_dim_is_aff_gen |]; easy. Qed.

Lemma dim_is_aff_indep_gen_equiv :
  forall {PE : E -> Prop} {n} {A : 'E^n.+1},
    has_aff_dim PE n -> inclF A PE -> is_aff_indep A <-> is_aff_gen PE A.
Proof.
intros; split; [apply is_aff_indep_dim_is_aff_gen |
    apply is_aff_gen_dim_is_aff_indep]; easy.
Qed.

End AffineSpace_FD_R_Facts.


Local Open Scope R_scope.
Local Open Scope Monoid_scope.
Local Open Scope Group_scope.


Section ModuleSpace_AffineSpace_Facts.

Context {E : ModuleSpace R_Ring}.

Definition affine_independent {n} (A : 'E^n.+1) :=
  is_free (liftF_S A - constF n (A ord0)).

Lemma affine_independent_equiv :
  forall {n} (A : 'E^n.+1), affine_independent A <-> is_aff_indep A.
Proof.
intros n A; split; intros HA.
apply (is_aff_indep_alt ord0); unfold frameF; rewrite skipF_first; easy.
unfold affine_independent; rewrite -skipF_first; apply HA.
Qed.

Lemma affine_independent_skipF :
  forall {n} {A : 'E^n.+2} i0,
    affine_independent A -> affine_independent (skipF A i0).
Proof.
move=>>; rewrite !affine_independent_equiv; apply is_aff_indep_skipF.
Qed.

Lemma affine_independent_comb_lin :
  forall {n} L1 L2 (A : 'E^n.+1),
    affine_independent A ->
    sum L1 = sum L2 -> comb_lin L1 A = comb_lin L2 A ->
    L1 = L2.
Proof.
intros n L1 L2 A HA HL HLA.
(* *)
assert (H : skipF L1 ord0 = skipF L2 ord0).
rewrite 2!skipF_first.
apply minus_zero_reg, HA; rewrite comb_lin_minus_l 2!comb_lin_minus_r.
apply: minus_zero_compat.
rewrite (minus_plus_l_eq (scal (L1 ord0) (A ord0))).
rewrite (minus_plus_l_eq (scal (L2 ord0) (A ord0)) (comb_lin (_ L2) _)).
rewrite -2!comb_lin_ind_l HLA; f_equal.
rewrite -2!scal_sum_l -2!scal_distr_r -2!sum_ind_l HL; easy.
(* *)
apply (eqF_skipF _ _ ord0); try easy.
apply plus_reg_r with (sum (skipF L1 ord0)); rewrite {2}H.
rewrite -2!(sum_skipF _ ord0); easy.
Qed.

Definition is_affine_generator {n} (A : 'E^n) : Prop :=
  forall x, exists L, sum L = 1 /\ x = comb_lin L A.

Lemma is_affine_generator_equiv :
  forall {n} (A : 'E^n), is_affine_generator A <-> is_aff_gen fullset A.
Proof.
intros n A; split; intros HA.
(* *)
apply subset_ext_equiv; split; try easy; intros x _.
destruct (HA x) as [L [HL1 HL2]], n as [|n].
rewrite sum_nil in HL1; contradict HL1; apply not_eq_sym, one_not_zero_R.
assert (HL1' : invertible (sum L)).
  rewrite HL1; replace 1 with (@one R_Ring); try easy; apply invertible_one.
apply aff_span_ex; exists L; split; try easy.
rewrite HL2; apply sym_eq, barycenter_ms_eq; easy.
(* *)
intros x; assert (Hx : aff_span A x) by now rewrite -HA.
induction Hx as [L HL].
destruct (barycenter_normalized L A (barycenter L A)) as [HL' HG]; try easy.
rewrite HG; exists (scal (/ sum L)%K L); split; try easy.
apply barycenter_ms_eq; easy.
Qed.

Lemma affine_independent_generator :
  forall {n} (A : 'E^n.+1),
    has_dim (@fullset E) n -> affine_independent A -> is_affine_generator A.
Proof.
move=> n A /(has_dim_aff (A ord0)) HE /affine_independent_equiv HA.
apply is_affine_generator_equiv.
apply is_aff_indep_dim_is_aff_gen; easy.
Qed.

End ModuleSpace_AffineSpace_Facts.
